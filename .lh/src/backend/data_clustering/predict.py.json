{
    "sourceFile": "src/backend/data_clustering/predict.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1733408300628,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1733408300628,
            "name": "Commit-0",
            "content": "import asyncio\nimport logging\nimport pandas as pd\nimport numpy as np\nimport time\nfrom typing import Dict, Any\nfrom src.backend.data_clustering.cluster_service import WeatherCluster\nfrom sklearn.ensemble import RandomForestClassifier, RandomForestRegressor\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom fastapi import HTTPException\nfrom sklearn.cluster import KMeans\nfrom src.logger import logger\n\nclass Predict:\n    def __init__(self):\n        \"\"\"\n        Initialize Predict class with RandomForest models and other utilities for weather data predictions.\n        \"\"\"\n        self.is_trained_temp = False\n        self.is_trained_season = False\n        self.last_trained_temp = None\n        self.last_trained_season = None\n        self.data_service = WeatherCluster()\n        self.scaler = StandardScaler()\n        self.temperature_model = RandomForestRegressor(n_estimators=100, random_state=42)\n        self.season_model = RandomForestClassifier(n_estimators=100, random_state=42)\n        self.features = [\"temp\", \"pressure\", \"humidity\", \"clouds\", \"visibility\", \"wind_speed\", \"wind_deg\"]\n\n    async def train_temperature_model(self) -> None:\n        \"\"\"\n        Train the temperature prediction model if not trained in the last 24 hours.\n        \"\"\"\n        try:\n            current_time = time.time()\n            if not self.last_trained_temp or (current_time - self.last_trained_temp) >= 24 * 3600:\n                df = await self.data_service.get_weather_data()\n                df = await self.data_service.process_data(df)\n                df[\"temp_shifted\"] = df[\"temp\"].shift(-1)\n                df.dropna(inplace=True)\n\n                X, y = df[self.features], df[\"temp_shifted\"]\n                X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n                self.temperature_model.fit(X_train, y_train)\n                mae = np.mean(np.abs(y_test - self.temperature_model.predict(X_test)))\n                logger.info(f\"Temperature prediction model trained. MAE: {mae:.2f}\")\n\n                self.is_trained_temp = True\n                self.last_trained_temp = current_time\n        except Exception as e:\n            logger.error(f\"Error training temperature model: {e}\")\n            raise\n\n    async def predict_next_day_temperature(self) -> float:\n        \"\"\"\n        Predict the next day's temperature using the trained model.\n        \"\"\"\n        try:\n            if not self.is_trained_temp:\n                await self.train_temperature_model()\n\n            df = await self.data_service.get_weather_data()\n            df = await self.data_service.process_data(df)\n            today_features = df[self.features].iloc[-1].to_frame().T\n            return self.temperature_model.predict(today_features)[0]\n\n        except Exception as e:\n            logger.error(f\"Error predicting temperature: {e}\")\n            raise\n\n    async def train_season_model(self) -> None:\n        \"\"\"\n        Train the season classification model if not trained in the last 24 hours.\n        \"\"\"\n        try:\n            current_time = time.time()\n            if not self.last_trained_season or (current_time - self.last_trained_season) >= 24 * 3600:\n                df = await self.data_service.get_weather_data()\n                df = await self.data_service.process_data(df)\n                df = self.data_service.customize_labels(df)\n\n                X, y = df[self.features], df[\"custom_label\"]\n                self.scaler.fit(X)\n                X_scaled = self.scaler.transform(X)\n\n                X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)\n\n                self.season_model.fit(X_train, y_train)\n                accuracy = self.season_model.score(X_test, y_test)\n                logger.info(f\"Season classification model trained. Accuracy: {accuracy:.2f}\")\n\n                self.is_trained_season = True\n                self.last_trained_season = current_time\n        except Exception as e:\n            logger.error(f\"Error training season model: {e}\")\n            raise\n\n    async def calculate_season_centroids_by_temp(self):\n        try: \n            data = await self.data_service.get_all_data_cluster()\n            \n            # Chuyển đổi cột 'date' sang dạng tháng\n            data['month'] = pd.to_datetime(data['date']).dt.month\n            \n            # Xác định mùa\n            def get_season(month):\n                if month in [3, 4, 5]:\n                    return 'spring'\n                elif month in [6, 7, 8]:\n                    return 'summer'\n                elif month in [9, 10, 11]:\n                    return 'autumn'\n                else:\n                    return 'winter'\n            \n            data['season'] = data['month'].apply(get_season)\n            \n            # Tính centroids (trung bình nhiệt độ theo mùa)\n            centroids = data.groupby('season')['temp'].mean().to_dict()\n            \n            return centroids\n        except Exception as e:\n            logger.error(f\"Error in calculate_season_centroids_by_temp: {e}\")\n            raise\n\n    \n    async def predict_season_probability(self, temp):\n        try:\n            centroids = await self.calculate_season_centroids_by_temp()\n            \n            if not centroids:\n                logger.error(\"Centroids are empty, unable to predict season probability.\")\n                raise ValueError(\"Centroids are empty.\")\n            \n            # Calculate distances\n            distances = {season: abs(temp - centroid) for season, centroid in centroids.items()}\n            \n            # Normalize distances to calculate probabilities (inverse distance weighting)\n            total_inverse_distance = sum(1 / d if d != 0 else float('inf') for d in distances.values())\n            probabilities = {season: (1 / distances[season] if distances[season] != 0 else 1e6) / total_inverse_distance \n                            for season in distances}\n            \n            # Prepare the result\n            result = {\n                \"distances\": distances,\n                \"probabilities\": probabilities\n            }\n            return result\n        except Exception as e:\n            logger.error(f\"Error in predict_season_probability: {e}\")\n            raise\n\n    \n    @staticmethod\n    def calculate_cluster_probabilities(predicted_temperature: float, kmeans_model: KMeans) -> Dict[str, Any]:\n        \"\"\"\n        Calculate probabilities of cluster memberships for the predicted temperature.\n        \"\"\"\n        try:\n            if not hasattr(kmeans_model, \"cluster_centers_\"):\n                raise ValueError(\"Invalid KMeans model. Ensure the model is properly trained.\")\n\n            centroids = kmeans_model.cluster_centers_\n            distances = [float(np.linalg.norm(predicted_temperature - centroid[0])) for centroid in centroids]\n            inverse_distances = [1 / d if d != 0 else 1e-9 for d in distances]\n            total_inverse = sum(inverse_distances)\n            probabilities = [float(dist / total_inverse) for dist in inverse_distances]\n\n            return {\n                \"distances\": {f\"cluster_{i}\": distances[i] for i in range(len(distances))},\n                \"probabilities\": {f\"cluster_{i}\": probabilities[i] for i in range(len(probabilities))}\n            }\n        except Exception as e:\n            logger.error(f\"Error calculating cluster probabilities: {e}\")\n            raise HTTPException(status_code=500, detail=\"Error calculating cluster probabilities.\")\n\n    async def predict_season_probabilities(self, data: Dict[str, Any]) -> Dict[str, float]:\n        \"\"\"\n        Predict season probabilities based on given weather data.\n        \"\"\"\n        try:\n            df = pd.DataFrame([data])\n            missing_features = set(self.features) - set(df.columns)\n            if missing_features:\n                raise ValueError(f\"Missing features: {missing_features}\")\n            df[\"temp\"] -= 273.15\n            df_scaled = self.scaler.transform(df[self.features])\n            probabilities = self.season_model.predict_proba(df_scaled)[0]\n\n            return {season: prob for season, prob in zip([\"Spring\", \"Summer\", \"Autumn\", \"Winter\"], probabilities)}\n        except Exception as e:\n            logger.error(f\"Error predicting season probabilities: {e}\")\n            raise\n\n    async def predict_season_for_day(self, sample_data: Dict[str, float]) -> str:\n        \"\"\"\n        Predict the season for a given day's weather data.\n        \n        Args:\n            sample_data (Dict[str, float]): Weather data for the day.\n        \n        Returns:\n            str: Predicted season (e.g., \"Spring\", \"Summer\", \"Autumn\", \"Winter\").\n        \"\"\"\n        try:\n            # Ensure the model is trained\n            if not self.is_trained_season:\n                raise ValueError(\"The season classification model has not been trained yet.\")\n\n            # Extract features and scale the input data\n            features = [sample_data[feature] for feature in self.features]\n            scaled_features = self.scaler.transform([features])\n\n            # Predict the season\n            predicted_label = self.season_model.predict(scaled_features)[0]\n\n            # Map the predicted label to a season name\n            label_to_season = {\n                0: \"Spring\",\n                1: \"Summer\",\n                2: \"Autumn\",\n                3: \"Winter\"\n            }\n\n            predicted_season = label_to_season.get(predicted_label, \"Unknown\")\n            logger.info(f\"Predicted season: {predicted_season}\")\n            return predicted_season\n\n        except Exception as e:\n            logger.error(f\"Error predicting season: {e}\")\n            raise HTTPException(status_code=500, detail=\"Error predicting season.\")\n\nasync def main():\n    cluster = WeatherCluster()\n    predict = Predict()\n    try:\n        await cluster.connect()\n        await predict.train_temperature_model()\n        await predict.train_season_model()\n        \n        result = await predict.predict_season_probability(30)\n        print(result)\n   \n    finally:\n        # Đảm bảo đóng cluster\n        if isinstance(cluster, WeatherCluster):\n            await cluster.close()\n            logger.info(\"Cluster session closed.\")\n        else:\n            logger.error(f\"Cluster is not a WeatherCluster instance: {type(cluster)}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\n"
        }
    ]
}