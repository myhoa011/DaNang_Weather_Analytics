{
    "sourceFile": "src/backend/data_clustering/data_clustering.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1733408228924,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1733408256716,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,18 +91,17 @@\n     lifespan=lifespan,  # Attach lifecycle manager\n )\n \n origins = [\n-    \"http://localhost:3000\",  # Domain của frontend\n-    # Thêm các domain khác nếu cần\n+    \"http://localhost:3000\", \n ]\n \n app.add_middleware(\n     CORSMiddleware,\n-    allow_origins=origins,  # Chỉ định domain được phép\n+    allow_origins=origins,  \n     allow_credentials=True,\n-    allow_methods=[\"*\"],  # Cho phép tất cả các phương thức (GET, POST, ...)\n-    allow_headers=[\"*\"],  # Cho phép tất cả các headers\n+    allow_methods=[\"*\"],  \n+    allow_headers=[\"*\"], \n )\n \n @app.get(\"/\")\n async def read_root():\n"
                },
                {
                    "date": 1733412946204,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,9 @@\n from contextlib import asynccontextmanager, suppress\n from src.backend.data_clustering.weather_model import WeatherData\n from typing import Dict, Any\n import pandas as pd\n-from src.db_api.controid import Centroid, CentroidsResponse\n+from .controid import Centroid, CentroidsResponse\n \n # Initialize global objects\n cluster = WeatherCluster()\n predict = Predict()\n"
                }
            ],
            "date": 1733408228924,
            "name": "Commit-0",
            "content": "from fastapi import FastAPI, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nimport asyncio\nfrom contextlib import AsyncExitStack\nfrom sklearn.cluster import KMeans\nfrom src.backend.data_clustering.cluster_service import WeatherCluster\nfrom src.backend.data_clustering.predict import Predict\nfrom src.logger import logger\nfrom contextlib import asynccontextmanager, suppress\nfrom src.backend.data_clustering.weather_model import WeatherData\nfrom typing import Dict, Any\nimport pandas as pd\nfrom src.db_api.controid import Centroid, CentroidsResponse\n\n# Initialize global objects\ncluster = WeatherCluster()\npredict = Predict()\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    tasks = []\n    try:\n        # Startup: Initialize WeatherCluster and Predictor\n        logger.info(\"Initializing WeatherCluster and Predictor...\")\n        await cluster.connect()\n        logger.info(\"WeatherCluster initialized successfully.\")\n\n        # Define background tasks\n        async def periodic_training():\n            while True:\n                try:\n                    logger.info(\"Starting periodic training for temperature model...\")\n                    await predict.train_temperature_model()\n                    logger.info(\"Temperature model trained successfully.\")\n                except Exception as e:\n                    logger.error(f\"Error during periodic training: {e}\")\n                await asyncio.sleep(24 * 3600)\n\n        async def periodic_prediction():\n            while True:\n                try:\n                    # Thêm delay trước khi bắt đầu để đảm bảo các service khác đã sẵn sàng\n                    await asyncio.sleep(5)\n                    \n                    while True:\n                        try:\n                            # Thực hiện dự đoán\n                            prediction_result = await predict.predict_next_day_temperature()\n                            logger.info(f\"Prediction completed: {prediction_result}\")\n                            \n                            # Đợi 24 giờ trước lần dự đoán tiếp theo\n                            await asyncio.sleep(24 * 60 * 60)  # 24 hours\n                            \n                        except Exception as inner_e:\n                            logger.error(f\"Error during prediction cycle: {inner_e}\")\n                            # Đợi một khoảng thời gian ngắn trước khi thử lại\n                            await asyncio.sleep(60)  # 1 minute\n                except Exception as e:\n                    logger.error(f\"Critical error in periodic prediction: {e}\")\n                    # Đợi trước khi khởi động lại vòng lặp\n                    await asyncio.sleep(60)\n\n\n        # Start background tasks\n        training_task = asyncio.create_task(periodic_training())\n        prediction_task = asyncio.create_task(periodic_prediction())\n        tasks.extend([training_task, prediction_task])\n\n        yield  # Yield control back to FastAPI\n\n    finally:\n        # Cancel background tasks\n        logger.info(\"Shutting down background tasks...\")\n        for task in tasks:\n            task.cancel()\n            with suppress(asyncio.CancelledError):\n                await task\n        logger.info(\"Background tasks have been shut down.\")\n\n        # Cleanup on shutdown\n        logger.info(\"Shutting down WeatherCluster and cleaning up resources...\")\n        await cluster.close()\n        logger.info(\"WeatherCluster shutdown complete.\")\n        \n# Create FastAPI app with lifespan management\napp = FastAPI(\n    title=\"Weather Prediction Service\",\n    description=\"Microservice for weather prediction using machine learning models.\",\n    version=\"1.0.0\",\n    lifespan=lifespan,  # Attach lifecycle manager\n)\n\norigins = [\n    \"http://localhost:3000\",  # Domain của frontend\n    # Thêm các domain khác nếu cần\n]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,  # Chỉ định domain được phép\n    allow_credentials=True,\n    allow_methods=[\"*\"],  # Cho phép tất cả các phương thức (GET, POST, ...)\n    allow_headers=[\"*\"],  # Cho phép tất cả các headers\n)\n\n@app.get(\"/\")\nasync def read_root():\n    return {\"message\": \"Hello World\"}\n\n@app.get(\"/api/predict-temp-tomorrow\")\nasync def get_predict_temp_tomorrow():\n    \"\"\"\n    API to predict tomorrow's temperature.\n    \"\"\"\n    try:\n        logger.info(\"Processing API request to predict tomorrow's temperature...\")\n        temp_tomorrow = await predict.predict_next_day_temperature()\n        logger.info(f\"Predicted temperature for tomorrow: {temp_tomorrow:.2f}°C\")\n        return {\"temperature_tomorrow\": temp_tomorrow}\n    except Exception as e:\n        logger.error(f\"Error predicting tomorrow's temperature: {e}\")\n        raise HTTPException(status_code=500, detail=\"Error predicting tomorrow's temperature.\")\n\n@app.get(\"/api/distances-probabilities\")\nasync def predict_temp_prob() -> Dict[str, Any]:\n    try:\n        logger.info(\"Processing API request to manually calculate probabilities...\")\n        \n        kmeans_model = KMeans(n_clusters=3, random_state=42)\n        raw_data = await cluster.get_weather_data()\n        processed_data = await cluster.process_data(raw_data)\n        kmeans_model.fit(processed_data[[\"temp\"]])\n        \n        predicted_temp = await predict.predict_next_day_temperature()\n        # Calculate cluster probabilities\n        cluster_probs = predict.calculate_cluster_probabilities(predicted_temp, kmeans_model)\n        \n        logger.info(\"Models predicted successfully.\")\n        return {\"result\": cluster_probs}\n    except Exception as e:\n        logger.error(f\"Error training models: {e}\")\n        raise HTTPException(status_code=500, detail=\"Error training models.\")\n\n@app.post(\"/api/predict-season-for-day\")\nasync def predict_season_for_day(data: WeatherData) -> Dict[str, str]:\n    try:\n        logger.info(f\"Received data: {data}\")\n        await predict.train_season_model()\n        logger.info(\"Processing API request to predict season for a day...\")\n        season_predict = await predict.predict_season_for_day(data.dict())\n        logger.info(\"Predicted season for day successfully.\")\n        return {\"season\": season_predict}\n    except Exception as e:\n        logger.error(f\"Error predicting season: {e}\")\n        raise HTTPException(status_code=500, detail=\"Error predicting season.\")\n\n@app.post(\"/api/cluster\")\nasync def cluster_weather_data():\n    \"\"\"\n    API nhận dữ liệu thời tiết, xử lý phân cụm và trả về kết quả cùng với centroids.\n    \"\"\"\n    try:\n        # Lấy dữ liệu thời tiết\n        logger.info(\"Fetching weather data...\")\n        weather_data = await cluster.get_weather_data()\n\n        # Kiểm tra nếu weather_data là None hoặc DataFrame rỗng\n        if weather_data is None or weather_data.empty:\n            logger.warning(\"No weather data received from source.\")\n            raise ValueError(\"No weather data available for clustering.\")\n\n        # Xử lý dữ liệu\n        logger.info(\"Processing weather data...\")\n        processed_data = await cluster.process_data(weather_data)\n\n        # Kiểm tra nếu DataFrame rỗng sau khi xử lý\n        if processed_data.empty:\n            logger.warning(\"Processed data is empty after processing.\")\n            raise ValueError(\"Processed weather data is empty.\")\n\n        # Phân cụm dữ liệu\n        logger.info(\"Clustering weather data...\")\n        clustered_data, centroids = cluster.cluster_data(processed_data)\n\n        # Ghi log kết quả\n        logger.info(f\"Clustering completed. Found {len(centroids)} centroids.\")\n        \n        centroids_serialized =  cluster.serialize_centroids(centroids.to_dict(\"records\"))\n        success = await cluster.save_centroids(centroids_serialized)\n        if success:\n            logger.info(\"centroids saved successfully.\")\n        else:\n            logger.error(\"Failed to save centroids to database.\")\n        \n        customized_data = cluster.customize_labels(clustered_data)    \n        cluster_data_serialized = cluster.serialize_cluster_data(customized_data.to_dict(\"records\"))\n        # Save cluster data\n        cluster_success = await cluster.save_data_cluster(cluster_data_serialized)\n        if cluster_success:\n            logger.info(\"Clustered data saved successfully.\")\n        else:\n            logger.error(\"Failed to save clustered data to database.\")\n        \n        clustered_data = clustered_data.head(10)\n        # Trả về kết quả\n        return {\n            \"status\": \"success\",\n            \"clustered_data\": clustered_data.to_dict(orient=\"records\"),\n            \"centroids\": centroids.to_dict(orient=\"records\"),\n        }\n\n    except ValueError as ve:\n        logger.error(f\"Validation error during clustering: {ve}\")\n        raise HTTPException(status_code=400, detail=str(ve))\n    except Exception as e:\n        logger.exception(f\"Unexpected error during clustering: {e}\")\n        raise HTTPException(status_code=500, detail=\"An error occurred during clustering.\")\n\n@app.get(\"/api/get-data-cluster\")\nasync def get_all_data_cluster():\n    \"\"\"\n    API để lấy toàn bộ dữ liệu cluster từ cơ sở dữ liệu thông qua hàm `get_all_data_cluster`.\n    \"\"\"\n    try:\n        logger.info(\"Processing API request to get all data cluster...\")\n        \n        # Gọi hàm để lấy dữ liệu cluster\n        data_cluster = await cluster.get_all_data_cluster()\n        \n        # Chuyển đổi dữ liệu DataFrame sang danh sách dictionary để trả về JSON\n        data_cluster_json = data_cluster.to_dict(orient=\"records\")\n        \n        logger.info(f\"Successfully retrieved {len(data_cluster)} cluster records.\")\n        return {\"data_cluster\": data_cluster_json}\n\n    except HTTPException as he:\n        logger.error(f\"HTTPException while fetching data cluster: {he.detail}\")\n        raise he\n\n    except Exception as e:\n        logger.error(f\"Unexpected error while fetching data cluster: {e}\")\n        raise HTTPException(status_code=500, detail=\"Error fetching data cluster.\")\n\n@app.get(\"/api/centroids\", response_model=CentroidsResponse)\nasync def get_centroids():\n    \"\"\"\n    API để lấy thông tin các centroids của cụm.\n    \"\"\"\n    try:\n        logger.info(\"Processing API request to get centroids...\")\n\n        # Gọi hàm cluster.get_centroids() để lấy dữ liệu\n        centroids = await cluster.get_centroids()\n        \n        print(centroids)\n\n        # Kiểm tra nếu không có centroids\n        if centroids.empty:\n            logger.warning(\"No centroids found in database.\")\n            return {\"status\": \"success\", \"data_cluster\": []}\n\n        # Chọn các cột cần thiết\n        centroids = centroids[['cluster_name', 'scaled_temp', 'temp']]\n\n        # Chuyển đổi DataFrame thành JSON\n        centroids_json = centroids.to_dict(orient=\"records\")\n\n        logger.info(f\"Successfully retrieved {len(centroids)} centroid records.\")\n\n        # Trả về dữ liệu\n        return {\n            \"status\": \"success\",\n            \"data_cluster\": centroids_json\n        }\n\n    except ValueError as ve:\n        # Log lỗi ValueError\n        logger.error(f\"ValueError while fetching centroids: {ve}\")\n        raise HTTPException(status_code=404, detail=str(ve))\n\n    except Exception as e:\n        # Log lỗi bất ngờ\n        logger.exception(f\"Unexpected error while fetching centroids: {e}\")\n        raise HTTPException(status_code=500, detail=\"Error fetching centroids.\")\n\n@app.get(\"/api/predict-probability-season\")\nasync def predict_probability_season(temp: float):\n    try:\n        result = await predict.predict_season_probability(temp)\n        return result\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=\"Internal server error.\")\n    \nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\n        \"src.backend.data_clustering.data_clustering:app\",\n        host=\"localhost\",\n        port=8004,\n        reload=True\n    )\n"
        }
    ]
}