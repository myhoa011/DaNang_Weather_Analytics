{
    "sourceFile": "src/backend/data_clustering/cluster_service.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1733410333824,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1733410352878,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -383,6 +383,5 @@\n     finally:\n         await cluster.close()\n \n if __name__ == \"__main__\":\n-    asyncio.run(main())\n-\n+    asyncio.run(main())\n\\ No newline at end of file\n"
                }
            ],
            "date": 1733410333823,
            "name": "Commit-0",
            "content": "import asyncio\nimport aiohttp\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.cluster import KMeans\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.ensemble import RandomForestClassifier, RandomForestRegressor\nfrom dotenv import load_dotenv\nfrom src.logger import logger\nimport os\nfrom typing import List, Dict, Any, Tuple\n\nload_dotenv()\n\nclass WeatherCluster:\n    def __init__(self):\n        \"\"\"\n        Khởi tạo WeatherCluster với các thành phần:\n        - KMeans: Thuật toán phân cụm.\n        - StandardScaler: Chuẩn hóa dữ liệu.\n        \"\"\"\n        self.db_api_url = os.getenv(\"DB_API_URL\")\n        self.session = None\n        self.scaler = StandardScaler()\n        self.kmeans_model = KMeans(n_clusters=4, random_state=42)\n        self.temperature_model = RandomForestRegressor(n_estimators=100, random_state=42)\n        self.season_model = RandomForestClassifier(n_estimators=100, random_state=42)\n        self.features = [\"temp\", \"pressure\", \"humidity\", \"clouds\", \"visibility\", \"wind_speed\", \"wind_deg\"]\n\n    async def connect(self):\n        if self.session is None or getattr(self.session, 'closed', True):\n            self.session = aiohttp.ClientSession()\n\n    async def close(self):\n        if self.session is not None and not self.session.closed:\n            await self.session.close()\n\n    async def get_weather_data(self) -> pd.DataFrame:\n        try:\n            await self.connect()\n            headers = {\n                \"Content-Type\": \"application/json\",\n                \"Accept\": \"application/json\",\n            }\n\n            async with self.session.get(f\"{self.db_api_url}/api/weather\", headers=headers) as response:\n                if response.status == 200:\n                    data = await response.json()\n                    if not data:\n                        logger.warning(\"No weather data retrieved.\")\n                        raise Exception(\"No content retrieved from API.\")\n                    df = pd.DataFrame(data)\n                    logger.info(f\"Retrieved {len(df)} weather records.\")\n                    return df\n                else:\n                    error = await response.text()\n                    raise Exception(f\"API error: {error}\")\n        except Exception as e:\n            logger.error(f\"Error fetching data: {e}\")\n            raise\n        finally:\n            await self.close()\n\n    async def process_data(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"\n        Xử lý dữ liệu thời tiết:\n        - Chuyển đổi cột thời gian.\n        - Thêm cột tháng.\n        - Thay thế giá trị thiếu bằng giá trị trung bình hoặc gần nhất.\n\n        Args:\n            df (pd.DataFrame): Dữ liệu gốc từ API.\n\n        Returns:\n            pd.DataFrame: Dữ liệu đã xử lý.\n        \"\"\"\n        try:\n            if df.empty:\n                raise ValueError(\"Input DataFrame is empty.\")\n\n            df[\"date\"] = pd.to_datetime(df[\"dt\"], unit=\"s\")\n            df[\"month\"] = df[\"date\"].dt.month\n            df[\"temp\"] = df[\"temp\"] - 273.15\n\n            for col in df.select_dtypes(include=[\"number\"]).columns:\n                df[col] = df[col].bfill().fillna(df[col].mean())\n\n            logger.info(\"Weather data processed successfully.\")\n            return df\n        except Exception as e:\n            logger.error(f\"Error processing data: {e}\")\n            raise\n\n    def cluster_data(self, df: pd.DataFrame) -> Tuple[pd.DataFrame, pd.DataFrame]:\n        \"\"\"\n        Phân cụm dữ liệu thời tiết bằng KMeans.\n\n        Args:\n            df (pd.DataFrame): Dữ liệu đã xử lý.\n\n        Returns:\n            Tuple[pd.DataFrame, pd.DataFrame]: \n                - Dữ liệu với nhãn cụm.\n                - Điểm centroid của từng cụm với nhãn mùa.\n        \"\"\"\n        try:\n            if df.empty:\n                raise ValueError(\"Input DataFrame is empty for clustering.\")\n\n            df[\"scaled_temp\"] = self.scaler.fit_transform(df[[\"temp\"]])\n            df[\"kmean_label\"] = self.kmeans_model.fit_predict(df[[\"scaled_temp\"]])\n\n            centroids = self.kmeans_model.cluster_centers_\n            centroid_df = pd.DataFrame(\n                centroids, columns=[\"scaled_temp\"], index=[f\"cluster_{i}\" for i in range(len(centroids))]\n            )\n            centroid_df[\"temp\"] = self.scaler.inverse_transform(centroid_df[[\"scaled_temp\"]])\n            centroid_df.reset_index(inplace=True)\n            centroid_df.rename(columns={\"index\": \"cluster_name\"}, inplace=True)\n\n            logger.info(f\"Weather data clustered successfully. Centroids:\\n{centroid_df}\")\n            return df, centroid_df\n        except Exception as e:\n            logger.error(f\"Error clustering data: {e}\")\n            raise\n\n    def customize_labels(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"\n        Tùy chỉnh nhãn cụm dựa trên tháng để phân thành 4 mùa:\n        - Mùa Xuân: Tháng 3 - 5.\n        - Mùa Hạ: Tháng 6 - 8.\n        - Mùa Thu: Tháng 9 - 11.\n        - Mùa Đông: Tháng 12 - 2.\n\n        Args:\n            df (pd.DataFrame): Dữ liệu với nhãn cụm.\n\n        Returns:\n            pd.DataFrame: Dữ liệu với nhãn cụm tùy chỉnh.\n        \"\"\"\n        try:\n            if df.empty:\n                raise ValueError(\"Input DataFrame is empty for customizing labels.\")\n\n            def assign_season(month):\n                if 3 <= month <= 5:\n                    return 0  # Mùa Xuân\n                elif 6 <= month <= 8:\n                    return 1  # Mùa Hạ\n                elif 9 <= month <= 11:\n                    return 2  # Mùa Thu\n                else:\n                    return 3  # Mùa Đông\n\n            df[\"custom_label\"] = df[\"month\"].apply(assign_season)\n            logger.info(\"Labels customized successfully.\")\n            return df\n        except Exception as e:\n            logger.error(f\"Error customizing labels: {e}\")\n            raise\n\n    def plot_temperature(self, df: pd.DataFrame):\n        \"\"\"\n        Vẽ biểu đồ nhiệt độ theo thời gian.\n\n        Args:\n            df (pd.DataFrame): Dữ liệu đã xử lý và phân cụm.\n        \"\"\"\n        try:\n            plt.figure(figsize=(14, 7))\n            colors = ['green', 'orange', 'brown', 'blue']\n            seasons = ['Spring', 'Summer', 'Autumn', 'Winter']\n\n            for season_label, color, season_name in zip(range(4), colors, seasons):\n                season_data = df[df[\"custom_label\"] == season_label]\n                plt.scatter(season_data[\"date\"], season_data[\"temp\"], label=season_name, color=color, s=10)\n\n            plt.title(\"Temperature Over Time by Season\")\n            plt.xlabel(\"Date\")\n            plt.ylabel(\"Temperature (°C)\")\n            plt.legend()\n            plt.grid()\n            plt.show()\n            logger.info(\"Temperature plot by season generated successfully.\")\n        except Exception as e:\n            logger.error(f\"Error plotting temperature: {e}\")\n\n    async def save_centroids(self, centroids: List[Dict[str, Any]]) -> bool:\n        \"\"\"\n        Lưu centroids vào cơ sở dữ liệu.\n\n        Args:\n            centroids (List[Dict[str, Any]]): Centroids đã serialize.\n\n        Returns:\n            bool: Trạng thái thành công hay thất bại.\n        \"\"\"\n        try:\n            await self.connect()\n\n            delete_url = f\"{self.db_api_url}/api/centroids\"\n            insert_url = f\"{self.db_api_url}/api/centroids\"\n            headers = {\"Content-Type\": \"application/json\"}\n\n            async with self.session.delete(delete_url, headers=headers) as delete_response:\n                if delete_response.status != 200:\n                    logger.warning(f\"Failed to delete old centroids: {delete_response.status}\")\n                    return False\n\n            async with self.session.post(insert_url, json=centroids, headers=headers) as insert_response:\n                if insert_response.status == 200:\n                    logger.info(\"Centroids saved successfully.\")\n                    return True\n                else:\n                    error = await insert_response.text()\n                    logger.error(f\"Failed to save centroids: {error}\")\n                    return False\n        except Exception as e:\n            logger.error(f\"Error saving centroids: {e}\")\n            return False\n        finally:\n            await self.close()\n\n    async def save_data_cluster(self, cluster_data: List[Dict[str, Any]]) -> bool:\n        \"\"\"\n        Xóa dữ liệu cũ và lưu dữ liệu phân cụm mới vào cơ sở dữ liệu thông qua API.\n        \n        Args:\n            cluster_data (List[Dict[str, Any]]): Dữ liệu phân cụm đã được serialize.\n        \n        Returns:\n            bool: Trạng thái thành công hay thất bại.\n        \"\"\"\n        try:\n            await self.connect()\n\n            # Xóa tất cả dữ liệu cũ\n            delete_url = f\"{self.db_api_url}/api/delete_all_data\"\n            delete_headers = {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json'\n            }\n            \n            async with self.session.delete(delete_url, headers=delete_headers) as delete_response:\n                if delete_response.status == 200:\n                    logger.info(\"Successfully deleted old cluster data.\")\n                else:\n                    delete_error = await delete_response.text()\n                    logger.error(f\"Failed to delete old cluster data: {delete_response.status}, error: {delete_error}\")\n                    return False\n            \n            if self.session is None:\n                await self.connect()\n\n            # Thêm dữ liệu mới\n            insert_url = f\"{self.db_api_url}/api/cluster_data/bulk\"\n            headers = {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json'\n            }\n\n            async with self.session.post(insert_url, json=cluster_data, headers=headers) as insert_response:\n                if insert_response.status == 200:\n                    result = await insert_response.json()\n                    logger.info(f\"Successfully saved {result['count']} cluster data.\")\n                    return True\n                else:\n                    insert_error = await insert_response.text()\n                    logger.error(f\"Failed to save cluster data: {insert_response.status}, error: {insert_error}\")\n                    return False\n\n        except Exception as e:\n            logger.error(f\"Error saving cluster data: {e}\")\n            return False\n        finally:\n            await self.close()\n\n    @staticmethod\n    def serialize_cluster_data(cluster_data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        \"\"\"\n        Chuyển đổi danh sách các bản ghi phân cụm thành dạng serializable để lưu vào cơ sở dữ liệu.\n\n        Args:\n            cluster_data (List[Dict[str, Any]]): Danh sách các bản ghi phân cụm.\n\n        Returns:\n            List[Dict[str, Any]]: Dữ liệu đã serialize.\n        \"\"\"\n        try:\n            serialized_data = [\n                {\n                    \"dt\": record[\"dt\"],\n                    \"temp\": record[\"temp\"],\n                    \"pressure\": record[\"pressure\"],\n                    \"humidity\": record[\"humidity\"],\n                    \"clouds\": record[\"clouds\"],\n                    \"visibility\": record[\"visibility\"],\n                    \"wind_speed\": record[\"wind_speed\"],\n                    \"wind_deg\": record[\"wind_deg\"],\n                    \"date\": record[\"date\"].isoformat() if isinstance(record[\"date\"], pd.Timestamp) else record[\"date\"],\n                    \"month\": record[\"month\"],\n                    \"scaled_temp\": record[\"scaled_temp\"],\n                    \"kmean_label\": record[\"kmean_label\"],\n                    \"custom_label\": record[\"custom_label\"],\n                }\n                for record in cluster_data\n            ]\n            logger.info(f\"Serialized {len(serialized_data)} records for database insertion.\")\n            return serialized_data\n        except Exception as e:\n            logger.error(f\"Error serializing cluster data: {e}\")\n            raise\n\n    @staticmethod\n    def serialize_centroids(centroids: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        \"\"\"\n        Serialize centroids for database insertion.\n\n        Args:\n            centroids (List[Dict[str, Any]]): Danh sách centroids.\n\n        Returns:\n            List[Dict[str, Any]]: Dữ liệu đã serialize.\n        \"\"\"\n        try:\n            serialized_data = [\n                {\n                    \"cluster_name\": record[\"cluster_name\"],\n                    \"temp\": float(record[\"temp\"]),\n                    \"scaled_temp\": float(record[\"scaled_temp\"]),\n                }\n                for record in centroids\n            ]\n            logger.info(f\"Serialized {len(serialized_data)} centroids for database insertion.\")\n            return serialized_data\n        except Exception as e:\n            logger.error(f\"Error serializing centroids: {e}\")\n            raise\n\nasync def main():\n    \"\"\"\n    Main pipeline:\n    - Fetch weather data.\n    - Process and cluster data.\n    - Serialize and save centroids and cluster data.\n    \"\"\"\n    cluster = WeatherCluster()\n    await cluster.connect()\n    try:\n        # Step 1: Fetch data\n        weather_data = await cluster.get_weather_data()\n\n        # Step 2: Process data\n        processed_data = cluster.process_data(weather_data)\n\n        # Step 3: Perform clustering\n        clustered_data, centroids = cluster.cluster_data(processed_data)\n        print(clustered_data.head())\n\n        # Step 4: Customize labels\n        customized_data = cluster.customize_labels(clustered_data)\n        \n        cluster.plot_temperature(processed_data)\n\n        # Step 5: Serialize and save centroids\n        centroids_serialized = cluster.serialize_centroids(centroids.to_dict(\"records\"))\n        success = await cluster.save_centroids(centroids_serialized)\n        if success:\n            logger.info(\"Centroids saved successfully.\")\n        else:\n            logger.error(\"Failed to save centroids to database.\")\n\n        # Step 6: Serialize and save clustered data\n        cluster_data_serialized = cluster.serialize_cluster_data(customized_data.to_dict(\"records\"))\n        \n        # Save cluster data\n        cluster_success = await cluster.save_data_cluster(cluster_data_serialized)\n        if cluster_success:\n            logger.info(\"Clustered data saved successfully.\")\n        else:\n            logger.error(\"Failed to save clustered data to database.\")\n    finally:\n        await cluster.close()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\n"
        }
    ]
}