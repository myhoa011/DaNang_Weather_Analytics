{
    "sourceFile": "src/db_api/db_api.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1733386792611,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1733386799515,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -328,9 +328,9 @@\n                 \"\"\"\r\n                 # Tạo danh sách giá trị từ dữ liệu đầu vào\r\n                 values = [\r\n                     (data.temp_predict, data.prediction_date, data.date)\r\n-                    for data in data_centroids\r\n+                    for data in data\r\n                 ]\r\n \r\n                 # Thực thi lệnh chèn dữ liệu hàng loạt\r\n                 await cur.executemany(query, values)\r\n"
                },
                {
                    "date": 1733408306284,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,190 +1,867 @@\n from fastapi import FastAPI, HTTPException\r\n+from fastapi.middleware.cors import CORSMiddleware\r\n from typing import List, Dict, Any\r\n import aiomysql\r\n-import httpx\r\n import os\r\n-import sys\r\n from dotenv import load_dotenv\r\n-from contextlib import asynccontextmanager\r\n+import asyncio\r\n+from datetime import datetime\r\n+import redis.asyncio as aioredis\r\n+import json\r\n+from pymysqlreplication import BinLogStreamReader\r\n+from pymysqlreplication.row_event import WriteRowsEvent\r\n+import pandas as pd\r\n \r\n-sys.path.append(\".\")\r\n from src.logger import logger\r\n from src.db_api.weather import WeatherData\r\n-from src.db_api.cluster import ClusterData\r\n-from src.db_api.controid import Centroid\r\n-from fastapi.middleware.cors import CORSMiddleware\r\n \r\n # Load environment variables\r\n load_dotenv()\r\n \r\n+app = FastAPI()\r\n+# Ngay sau khi khởi tạo app\r\n+app.add_middleware(\r\n+    CORSMiddleware,\r\n+    allow_origins=[\"*\"],\r\n+    allow_credentials=True,\r\n+    allow_methods=[\"*\"],\r\n+    allow_headers=[\"*\"], \r\n+)\r\n+weather_api = None\r\n+\r\n+@app.on_event(\"startup\")\r\n+async def startup_event():\r\n+    \"\"\"Initialize database connection on startup\"\"\"\r\n+    global weather_api\r\n+    try:\r\n+        # Create WeatherAPI instance first\r\n+        weather_api = WeatherAPI()\r\n+        # Connect database\r\n+        await weather_api.connect_pool()\r\n+        logger.info(\"Database connection initialized\")\r\n+        \r\n+        # Start binlog listener in background\r\n+        weather_api.binlog_task = asyncio.create_task(weather_api.start_binlog_listener())\r\n+        \r\n+    except Exception as e:\r\n+        logger.error(f\"Error during startup: {e}\")\r\n+        raise\r\n+\r\n class WeatherAPI:\r\n-    \"\"\"\r\n-    Weather API class that handles database connections and service calls.\r\n-    Provides methods for database operations and service integrations.\r\n-    \"\"\"\r\n     def __init__(self):\r\n-        \"\"\"Initialize WeatherAPI with database pool and service endpoints\"\"\"\r\n         self.pool = None\r\n-        # Backend service endpoints for future integrations\r\n-        self.service_urls = {\r\n-            \"analysis\": \"http://localhost:8001/analyze\",\r\n-            \"clustering\": \"http://localhost:8002/cluster\",\r\n-            \"classification\": \"http://localhost:8003/classify\",\r\n-            \"prediction\": \"http://localhost:8004/predict\"\r\n-        }\r\n+        self.binlog_task = None\r\n+        self.is_listening = False\r\n+        self.binlog_stream = None\r\n+        self.redis = None\r\n+        self.initial_count = 0\r\n+        self.is_initial_load = True\r\n+        self.binlog_queue = asyncio.Queue()\r\n \r\n-    async def connect_db(self):\r\n-        \"\"\"\r\n-        Initialize database connection pool.\r\n-        Uses environment variables for database configuration.\r\n-        \"\"\"\r\n+    async def connect_pool(self):\r\n+        \"\"\"Initialize database and redis connection pools\"\"\"\r\n         if not self.pool:\r\n+            # Connect MySQL\r\n             self.pool = await aiomysql.create_pool(\r\n                 host=os.getenv('DB_HOST'),\r\n                 port=int(os.getenv('DB_PORT')),\r\n                 user=os.getenv('DB_USER'),\r\n                 password=os.getenv('DB_PASSWORD'),\r\n                 db=os.getenv('DB_NAME'),\r\n                 autocommit=True\r\n             )\r\n+            \r\n+            # Connect Redis\r\n+            self.redis = await aioredis.from_url(\r\n+                f'redis://redis:6379',\r\n+                password=os.getenv('REDIS_PASSWORD')\r\n+            )\r\n \r\n-    async def close_db(self):\r\n-        \"\"\"\r\n-        Close database connection pool.\r\n-        Should be called when shutting down the application.\r\n-        \"\"\"\r\n+    async def start_binlog_stream(self):\r\n+        \"\"\"Start MySQL binlog stream\"\"\"\r\n+        try:\r\n+            if self.binlog_stream:\r\n+                self.binlog_stream.close()\r\n+                \r\n+            mysql_settings = {\r\n+                \"host\": os.getenv('DB_HOST'),\r\n+                \"port\": int(os.getenv('DB_PORT')),\r\n+                \"user\": os.getenv('DB_USER'),\r\n+                \"passwd\": os.getenv('DB_PASSWORD')\r\n+            }\r\n+            \r\n+            # Get current binlog position\r\n+            async with self.pool.acquire() as conn:\r\n+                async with conn.cursor() as cur:\r\n+                    await cur.execute(\"SHOW MASTER STATUS\")\r\n+                    result = await cur.fetchone()\r\n+                    if result:\r\n+                        log_file, log_pos = result[0], result[1]\r\n+                    else:\r\n+                        log_file, log_pos = None, None\r\n+                        \r\n+                    # Get column names\r\n+                    await cur.execute(\"\"\"\r\n+                        SELECT COLUMN_NAME \r\n+                        FROM INFORMATION_SCHEMA.COLUMNS \r\n+                        WHERE TABLE_SCHEMA = %s \r\n+                        AND TABLE_NAME = 'processed_weather_data'\r\n+                        ORDER BY ORDINAL_POSITION\r\n+                    \"\"\", (os.getenv('DB_NAME'),))\r\n+                    columns = [row[0] for row in await cur.fetchall()]\r\n+            \r\n+            self.binlog_stream = BinLogStreamReader(\r\n+                connection_settings=mysql_settings,\r\n+                server_id=1000,\r\n+                only_events=[WriteRowsEvent],\r\n+                only_tables=['processed_weather_data'],\r\n+                only_schemas=[os.getenv('DB_NAME')],\r\n+                log_file=log_file,\r\n+                log_pos=log_pos,\r\n+                resume_stream=True,\r\n+                blocking=True,\r\n+                slave_heartbeat=30.0,\r\n+                freeze_schema=False\r\n+            )\r\n+            logger.info(f\"Started MySQL binlog stream from {log_file}:{log_pos}\")\r\n+            \r\n+            # Store column names for later use\r\n+            self.table_columns = columns\r\n+            \r\n+        except Exception as e:\r\n+            logger.error(f\"Error starting binlog stream: {e}\")\r\n+            self.binlog_stream = None\r\n+            await asyncio.sleep(5)\r\n+\r\n+    async def start_binlog_listener(self):\r\n+        \"\"\"Start binlog listener in background\"\"\"\r\n+        try:\r\n+            # Start binlog reader in a separate task\r\n+            reader_task = asyncio.create_task(self.read_binlog())\r\n+            # Start processor in a separate task\r\n+            processor_task = asyncio.create_task(self.process_binlog_queue())\r\n+            \r\n+            # Wait for both tasks\r\n+            await asyncio.gather(reader_task, processor_task)\r\n+            \r\n+        except Exception as e:\r\n+            logger.error(f\"Error in binlog listener: {e}\")\r\n+            raise\r\n+\r\n+    async def read_binlog(self):\r\n+        \"\"\"Read binlog in background thread\"\"\"\r\n+        while True:\r\n+            try:\r\n+                if not self.binlog_stream:\r\n+                    await self.start_binlog_stream()\r\n+                    continue\r\n+\r\n+                def read_next():\r\n+                    try:\r\n+                        # Sử dụng fetchone() thay vì next()\r\n+                        for event in self.binlog_stream:\r\n+                            return event\r\n+                    except Exception as e:\r\n+                        logger.error(f\"Error reading binlog: {e}\")\r\n+                        return None\r\n+\r\n+                # Read binlog in thread pool\r\n+                event = await asyncio.get_event_loop().run_in_executor(None, read_next)\r\n+                \r\n+                if event and isinstance(event, WriteRowsEvent):\r\n+                    logger.info(f\"Received WriteRowsEvent with {len(event.rows)} rows\")\r\n+                    # Put event into queue for processing\r\n+                    await self.binlog_queue.put(event)\r\n+                    \r\n+            except Exception as e:\r\n+                logger.error(f\"Error in binlog reader: {e}\")\r\n+                if self.binlog_stream:\r\n+                    self.binlog_stream.close()\r\n+                    self.binlog_stream = None\r\n+                await asyncio.sleep(0.1)\r\n+\r\n+    async def process_binlog_queue(self):\r\n+        \"\"\"Process events from binlog queue\"\"\"\r\n+        initial_events = []\r\n+        redis = await aioredis.from_url('redis://redis:6379', password=os.getenv('REDIS_PASSWORD'))\r\n+\r\n+        try:\r\n+            while True:\r\n+                event = await self.binlog_queue.get()\r\n+                \r\n+                if self.is_initial_load:\r\n+                    initial_events.extend(event.rows)\r\n+                    logger.info(f\"Added to initial load buffer. Current size: {len(initial_events)}\")\r\n+                    \r\n+                    if len(initial_events) >= 34400:\r\n+                        logger.info(f\"Initial load complete with {len(initial_events)} rows\")\r\n+                        self.is_initial_load = False\r\n+                        \r\n+                        # Gửi signal qua Redis\r\n+                        await redis.set('db_initial_load_complete', '1')\r\n+                        await redis.publish('db_status', 'initial_load_complete')\r\n+                        \r\n+                        # Process all initial events\r\n+                        for row in initial_events:\r\n+                            await self.process_weather_event(row['values'], is_initial=True)\r\n+                        initial_events.clear()\r\n+                else:\r\n+                    # Process normal binlog event\r\n+                    for row in event.rows:\r\n+                        await self.process_weather_event(row['values'], is_initial=False)\r\n+                \r\n+                self.binlog_queue.task_done()\r\n+                \r\n+        except Exception as e:\r\n+            logger.error(f\"Error processing binlog event: {e}\")\r\n+        finally:\r\n+            await redis.close()\r\n+\r\n+    async def process_weather_event(self, values, is_initial=False):\r\n+        \"\"\"Process a weather event\"\"\"\r\n+        try:\r\n+            \r\n+            # Map UNKNOWN_COL to actual column names\r\n+            weather_data = {\r\n+                'dt': values['UNKNOWN_COL0'],\r\n+                'temp': values['UNKNOWN_COL1'],\r\n+                'pressure': values['UNKNOWN_COL2'],\r\n+                'humidity': values['UNKNOWN_COL3'],\r\n+                'clouds': values['UNKNOWN_COL4'],\r\n+                'visibility': values['UNKNOWN_COL5'],\r\n+                'wind_speed': values['UNKNOWN_COL6'],\r\n+                'wind_deg': values['UNKNOWN_COL7']\r\n+            }\r\n+            \r\n+            # Chỉ publish khi không phải initial load\r\n+            if not is_initial:\r\n+                await self.publish_weather_data(weather_data)\r\n+            \r\n+        except Exception as e:\r\n+            logger.error(f\"Error processing weather event: {e}\")\r\n+            logger.error(f\"Values received: {values}\")\r\n+\r\n+    async def close_pool(self):\r\n+        \"\"\"Close database connection\"\"\"\r\n+        self.is_listening = False\r\n+        \r\n+        if self.binlog_task:\r\n+            self.binlog_task.cancel()\r\n+            try:\r\n+                await self.binlog_task\r\n+            except asyncio.CancelledError:\r\n+                pass\r\n+                \r\n         if self.pool:\r\n             self.pool.close()\r\n             await self.pool.wait_closed()\r\n+        logger.info(\"Database connection closed\")\r\n \r\n-    async def _call_service(self, service: str, weather_data: WeatherData) -> Dict[str, Any]:\r\n-        \"\"\"\r\n-        Call backend service with weather data\r\n-        Args:\r\n-            service: Service name to call\r\n-            weather_data: Weather data to process\r\n-        Returns:\r\n-            JSON response from service\r\n-        \"\"\"\r\n-        async with httpx.AsyncClient() as client:\r\n-            response = await client.post(\r\n-                self.service_urls[service],\r\n-                json=weather_data.dict(),\r\n-                timeout=30.0\r\n-            )\r\n-            return response.json()\r\n+    async def publish_weather_data(self, weather_data):\r\n+        \"\"\"Publish weather data to Redis\"\"\"\r\n+        try:\r\n+            # Convert to JSON string\r\n+            data_str = json.dumps(weather_data)\r\n+            \r\n+            # Publish to Redis channel\r\n+            await self.redis.publish('weather_data', data_str)\r\n+            logger.info(f\"Published weather data: {data_str}\")\r\n+            \r\n+        except Exception as e:\r\n+            logger.error(f\"Error publishing weather data: {e}\")\r\n+            logger.error(f\"Weather data: {weather_data}\")\r\n \r\n-@asynccontextmanager\r\n-async def lifespan(app: FastAPI):\r\n-    \"\"\"Lifespan events handler\"\"\"\r\n-    # Startup\r\n-    logger.info(\"Connecting to database...\")\r\n-    await weather_api.connect_db()\r\n-    yield\r\n-    # Shutdown\r\n-    logger.info(\"Closing database connection...\")\r\n-    await weather_api.close_db()\r\n-\r\n # Initialize FastAPI app with lifespan\r\n app = FastAPI(\r\n     title=\"Weather API\",\r\n     lifespan=lifespan\r\n )\r\n \r\n-origins = [\r\n-    \"http://localhost:3000\",  # Domain của frontend\r\n-    # Thêm các domain khác nếu cần\r\n-]\r\n+weather_api = WeatherAPI()\r\n \r\n-app.add_middleware(\r\n-    CORSMiddleware,\r\n-    allow_origins=origins,  # Chỉ định domain được phép\r\n-    allow_credentials=True,\r\n-    allow_methods=[\"*\"],  # Cho phép tất cả các phương thức (GET, POST, ...)\r\n-    allow_headers=[\"*\"],  # Cho phép tất cả các headers\r\n-)\r\n+# FastAPI endpoints\r\n+@app.on_event(\"shutdown\")\r\n+async def shutdown():\r\n+    \"\"\"Close database connection on shutdown\"\"\"\r\n+    if weather_api:\r\n+        await weather_api.close_pool()\r\n \r\n-weather_api = WeatherAPI()\r\n+@app.get(\"/health\")\r\n+async def health_check():\r\n+    try:\r\n+        # Kiểm tra kết nối MySQL\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor() as cur:\r\n+                await cur.execute(\"SELECT 1\")\r\n+                await cur.fetchone()\r\n+        \r\n+        # Kiểm tra kết nối Redis\r\n+        await weather_api.redis.ping()\r\n+        \r\n+        return {\"status\": \"healthy\"}\r\n+    except Exception as e:\r\n+        raise HTTPException(status_code=503, detail=str(e))\r\n \r\n-@app.post(\"/api/raw_weather/bulk\")\r\n-async def save_raw_weather_bulk(raw_data_list: List[WeatherData]) -> Dict[str, Any]:\r\n-    \"\"\"\r\n-    Save multiple raw weather data entries in bulk.\r\n+@app.post(\"/api/weather/bulk\")\r\n+async def insert_weather_bulk(raw_data_list: List[WeatherData], processed_data_list: List[WeatherData]):\r\n+    \"\"\"Insert bulk weather data - both raw and processed\"\"\"\r\n+    try:\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor() as cur:\r\n+                # Insert raw data\r\n+                await cur.executemany(\"\"\"\r\n+                    INSERT INTO raw_weather_data \r\n+                    (dt, temp, pressure, humidity, clouds, visibility, wind_speed, wind_deg)\r\n+                    VALUES (%(dt)s, %(temp)s, %(pressure)s, %(humidity)s, \r\n+                            %(clouds)s, %(visibility)s, %(wind_speed)s, %(wind_deg)s)\r\n+                \"\"\", [data.model_dump() for data in raw_data_list])\r\n+\r\n+                # Insert processed data\r\n+                await cur.executemany(\"\"\"\r\n+                    INSERT INTO processed_weather_data \r\n+                    (dt, temp, pressure, humidity, clouds, visibility, wind_speed, wind_deg)\r\n+                    VALUES (%(dt)s, %(temp)s, %(pressure)s, %(humidity)s, \r\n+                            %(clouds)s, %(visibility)s, %(wind_speed)s, %(wind_deg)s)\r\n+                \"\"\", [data.model_dump() for data in processed_data_list])\r\n+                \r\n+                return {\r\n+                    \"message\": \"Bulk insert successful\",\r\n+                    \"count\": len(processed_data_list)\r\n+                }\r\n+\r\n+    except Exception as e:\r\n+        logger.error(f\"Error bulk inserting weather data: {e}\")\r\n+        raise HTTPException(status_code=500, detail=str(e))\r\n+\r\n+@app.get(\"/api/weather\")\r\n+async def get_weather_data():\r\n+    \"\"\"Get all weather data\"\"\"\r\n+    try:\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor() as cur:\r\n+                # Get all processed weather data\r\n+                await cur.execute(\"\"\"\r\n+                    SELECT \r\n+                        dt, temp, pressure, humidity, \r\n+                        clouds, visibility, wind_speed, wind_deg\r\n+                    FROM processed_weather_data \r\n+                    ORDER BY dt DESC\r\n+                \"\"\")\r\n+                \r\n+                # Fetch all records\r\n+                records = await cur.fetchall()\r\n+                \r\n+                # Convert to list of dicts\r\n+                result = []\r\n+                for record in records:\r\n+                    result.append({\r\n+                        'dt': record[0],\r\n+                        'temp': record[1],\r\n+                        'pressure': record[2],\r\n+                        'humidity': record[3],\r\n+                        'clouds': record[4],\r\n+                        'visibility': record[5],\r\n+                        'wind_speed': record[6],\r\n+                        'wind_deg': record[7]\r\n+                    })\r\n+                \r\n+                logger.info(f\"Retrieved {len(result)} weather records\")\r\n+                return result\r\n+\r\n+    except Exception as e:\r\n+        logger.error(f\"Error getting weather data: {e}\")\r\n+        raise HTTPException(status_code=500, detail=str(e))\r\n+\r\n+@app.post(\"/api/weather/predictions\")\r\n+async def save_predictions(predictions: List[dict]):\r\n+    \"\"\"Save weather predictions to database\"\"\"\r\n+    try:\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor() as cur:\r\n+                # Insert predictions with ON DUPLICATE KEY UPDATE\r\n+                await cur.executemany(\"\"\"\r\n+                    INSERT INTO predictions \r\n+                    (dt, temp, prediction_hour, hour, day, month, year, created_at, formatted_time)\r\n+                    VALUES (\r\n+                        %(dt)s, %(temp)s, %(prediction_hour)s, \r\n+                        %(hour)s, %(day)s, %(month)s, %(year)s,\r\n+                        %(created_at)s, %(formatted_time)s\r\n+                    )\r\n+                \"\"\", predictions)\r\n+                \r\n+                await conn.commit()\r\n+                \r\n+                logger.info(f\"Saved {len(predictions)} predictions to database\")\r\n+                return {\"message\": f\"Saved {len(predictions)} predictions\"}\r\n+\r\n+    except Exception as e:\r\n+        logger.error(f\"Error saving predictions: {e}\")\r\n+        raise HTTPException(status_code=500, detail=str(e))\r\n+\r\n+###########api manhdung\r\n+#FILTER\r\n+@app.get(\"/filter\")\r\n+async def get_filer() -> List[Dict[str, Any]]:  \r\n+    try:\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n+                query = \"SELECT * FROM processed_weather_data ORDER BY dt DESC\"\r\n+                await cur.execute(query)\r\n+                results = await cur.fetchall()\r\n+        \r\n+        # Chuyển đổi dữ liệu sang DataFrame\r\n+        df = pd.DataFrame(results)\r\n+        df = df.sort_values('dt')\r\n+        \r\n+        # Chuyển timestamp sang định dạng datetime string\r\n+        df['dt'] = df['dt'].apply(lambda x: datetime.utcfromtimestamp(int(x)).strftime('%Y-%m-%d %H:%M:%S'))\r\n+         \r\n+        # Chuyển đổi nhiệt độ từ °K sang °C\r\n+        df['temp'] = df['temp'].apply(lambda f: f-273.15)\r\n+        \r\n+        # Chuyển đổi đơn vị tầm nhìn từ m sang km\r\n+        df['visibility'] = df['visibility'].apply(lambda f: f/1000)\r\n+        \r\n+        # Chuyển timestamp sang string để JSON serializable\r\n+        df['dt'] = df['dt'].astype(str)\r\n+        \r\n+        result = df.to_dict(orient='records')   \r\n+        return result\r\n+    except Exception as e:\r\n+        raise HTTPException(status_code=500, detail=str(e))\r\n     \r\n-    Args:\r\n-        raw_data_list (List[WeatherData]): List of weather data objects to be saved\r\n+#nhóm theo ngày\r\n+@app.get(\"/filterDay\")\r\n+async def get_filer() -> List[Dict[str, Any]]:  \r\n+    try:\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n+                query = \"SELECT * FROM processed_weather_data ORDER BY dt DESC\"\r\n+                await cur.execute(query)\r\n+                results = await cur.fetchall()\r\n         \r\n-    Returns:\r\n-        Dict[str, Any]: Response containing count of saved entries and status message\r\n+        # Chuyển đổi dữ liệu sang DataFrame\r\n+        df = pd.DataFrame(results)\r\n+        df = df.sort_values('dt')\r\n         \r\n-    Raises:\r\n-        HTTPException: If database operation fails\r\n+        # Chuyển timestamp sang định dạng datetime string\r\n+        df['dt'] = df['dt'].apply(lambda x: datetime.utcfromtimestamp(int(x)).strftime('%Y-%m-%d %H:%M:%S'))\r\n+         \r\n+        # Chuyển đổi nhiệt độ từ °K sang °C\r\n+        df['temp'] = df['temp'].apply(lambda f: f-273.15)\r\n+        \r\n+        # Chuyển đổi đơn vị tầm nhìn từ m sang km\r\n+        df['visibility'] = df['visibility'].apply(lambda f: f/1000)\r\n+        \r\n+        # Chuyển cột dt sang định dạng datetime\r\n+        df['dt'] = pd.to_datetime(df['dt'])\r\n+\r\n+        # Tạo cột date\r\n+        df['date'] = df['dt'].dt.date\r\n+\r\n+        # Nhóm dữ liệu theo ngày\r\n+        daily_data = df.groupby('date').mean().reset_index()\r\n+        \r\n+        # Chuyển timestamp sang string để JSON serializable\r\n+        daily_data['date'] = daily_data['date'].astype(str)\r\n+        \r\n+        result = daily_data.to_dict(orient='records')   \r\n+        return result\r\n+    except Exception as e:\r\n+        raise HTTPException(status_code=500, detail=str(e))   \r\n+ \r\n+#nhóm theo tuần\r\n+@app.get(\"/filterWeek\")\r\n+async def get_filer() -> List[Dict[str, Any]]:  \r\n+    try:\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n+                query = \"SELECT * FROM processed_weather_data ORDER BY dt DESC\"\r\n+                await cur.execute(query)\r\n+                results = await cur.fetchall()\r\n+        \r\n+        # Chuyển đổi dữ liệu sang DataFrame\r\n+        df = pd.DataFrame(results)\r\n+        df = df.sort_values('dt')\r\n+        \r\n+        # Chuyển timestamp sang định dạng datetime string\r\n+        df['dt'] = df['dt'].apply(lambda x: datetime.utcfromtimestamp(int(x)).strftime('%Y-%m-%d %H:%M:%S'))\r\n+         \r\n+        # Chuyển đổi nhiệt độ từ °K sang °C\r\n+        df['temp'] = df['temp'].apply(lambda f: f-273.15)\r\n+        \r\n+        # Chuyển đổi đơn vị tầm nhìn từ m sang km\r\n+        df['visibility'] = df['visibility'].apply(lambda f: f/1000)\r\n+        \r\n+        # Chuyển cột dt sang định dạng datetime\r\n+        df['dt'] = pd.to_datetime(df['dt'])\r\n+\r\n+        # Tạo cột week và year để nhóm\r\n+        df['week'] = df['dt'].dt.isocalendar().week\r\n+        df['year'] = df['dt'].dt.year\r\n+\r\n+        # Nhóm dữ liệu theo tuần và năm\r\n+        weekly_data = df.groupby(['year', 'week']).mean().reset_index()\r\n+\r\n+        # Chuyển đổi cột week và year thành string để JSON serializable\r\n+        weekly_data['week'] = weekly_data['week'].astype(str)\r\n+        weekly_data['year'] = weekly_data['year'].astype(str)\r\n+\r\n+        # Kết hợp year và week vào một cột duy nhất để dễ hiểu\r\n+        weekly_data['year_week'] = weekly_data['year'] + '-W' + weekly_data['week']\r\n+\r\n+        # Loại bỏ các cột không cần thiết\r\n+        weekly_data = weekly_data.drop(columns=['year', 'week'])\r\n+        \r\n+        # Chuyển timestamp sang string để JSON serializable\r\n+        weekly_data['year_week'] = weekly_data['year_week'].astype(str)\r\n+        \r\n+        result = weekly_data.to_dict(orient='records')   \r\n+        return result\r\n+    except Exception as e:\r\n+        raise HTTPException(status_code=500, detail=str(e))  \r\n+    \r\n+#nhóm theo tháng\r\n+@app.get(\"/filterMonth\")\r\n+async def get_filer() -> List[Dict[str, Any]]:  \r\n+    try:\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n+                query = \"SELECT * FROM processed_weather_data ORDER BY dt DESC\"\r\n+                await cur.execute(query)\r\n+                results = await cur.fetchall()\r\n+        \r\n+        # Chuyển đổi dữ liệu sang DataFrame\r\n+        df = pd.DataFrame(results)\r\n+        df = df.sort_values('dt')\r\n+        \r\n+        # Chuyển timestamp sang định dạng datetime string\r\n+        df['dt'] = df['dt'].apply(lambda x: datetime.utcfromtimestamp(int(x)).strftime('%Y-%m-%d %H:%M:%S'))\r\n+         \r\n+        # Chuyển đổi nhiệt độ từ °K sang °C\r\n+        df['temp'] = df['temp'].apply(lambda f: f-273.15)\r\n+        \r\n+        # Chuyển đổi đơn vị tầm nhìn từ m sang km\r\n+        df['visibility'] = df['visibility'].apply(lambda f: f/1000)\r\n+        \r\n+        # Chuyển cột dt sang định dạng datetime\r\n+        df['dt'] = pd.to_datetime(df['dt'])\r\n+\r\n+        # Tạo cột month để nhóm\r\n+        df['month'] = df['dt'].dt.strftime('%Y-%m')\r\n+\r\n+        # Nhóm dữ liệu theo tuần và năm\r\n+        monthly_data = df.groupby('month').mean().reset_index()\r\n+  \r\n+        # Chuyển timestamp sang string để JSON serializable\r\n+        monthly_data['month'] = monthly_data['month'].astype(str)\r\n+        \r\n+        result = monthly_data.to_dict(orient='records')   \r\n+        return result\r\n+    except Exception as e:\r\n+        raise HTTPException(status_code=500, detail=str(e))  \r\n+    \r\n+    \r\n+#RE-SAMPLING về tháng TREND\r\n+@app.get(\"/resampleMonth\")\r\n+async def get_filer() -> List[Dict[str, Any]]:  \r\n+    try:\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n+                query = \"SELECT * FROM processed_weather_data ORDER BY dt DESC\"\r\n+                await cur.execute(query)\r\n+                results = await cur.fetchall()\r\n+        \r\n+        # Chuyển đổi dữ liệu sang DataFrame\r\n+        df = pd.DataFrame(results)\r\n+        df = df.sort_values('dt')\r\n+        \r\n+        # Chuyển timestamp sang định dạng datetime string\r\n+        df['dt'] = df['dt'].apply(lambda x: datetime.utcfromtimestamp(int(x)).strftime('%Y-%m-%d %H:%M:%S'))\r\n+         \r\n+        # Chuyển đổi nhiệt độ từ °K sang °C\r\n+        df['temp'] = df['temp'].apply(lambda f: f-273.15)\r\n+        \r\n+        # Chuyển đổi đơn vị tầm nhìn từ m sang km\r\n+        df['visibility'] = df['visibility'].apply(lambda f: f/1000)\r\n+        \r\n+        # Chuyển cột dt sang định dạng datetime\r\n+        df['dt'] = pd.to_datetime(df['dt'])\r\n+\r\n+        # Tạo cột month để nhóm\r\n+        df['month'] = df['dt'].dt.strftime('%Y-%m')\r\n+\r\n+        # Nhóm dữ liệu theo tháng\r\n+        monthly_data = df.groupby('month').median().reset_index()\r\n+  \r\n+        # Chuyển timestamp sang string để JSON serializable\r\n+        monthly_data['month'] = monthly_data['month'].astype(str)\r\n+        \r\n+        result = monthly_data.to_dict(orient='records')   \r\n+        return result\r\n+    except Exception as e:\r\n+        raise HTTPException(status_code=500, detail=str(e))  \r\n+    \r\n+#RE-SAMPLING về tuần TREND\r\n+@app.get(\"/resampleWeek\")\r\n+async def get_filer() -> List[Dict[str, Any]]:  \r\n+    try:\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n+                query = \"SELECT * FROM processed_weather_data ORDER BY dt DESC\"\r\n+                await cur.execute(query)\r\n+                results = await cur.fetchall()\r\n+        \r\n+        # Chuyển đổi dữ liệu sang DataFrame\r\n+        df = pd.DataFrame(results)\r\n+        df = df.sort_values('dt')\r\n+        \r\n+        # Chuyển timestamp sang định dạng datetime string\r\n+        df['dt'] = df['dt'].apply(lambda x: datetime.utcfromtimestamp(int(x)).strftime('%Y-%m-%d %H:%M:%S'))\r\n+         \r\n+        # Chuyển đổi nhiệt độ từ °K sang °C\r\n+        df['temp'] = df['temp'].apply(lambda f: f-273.15)\r\n+        \r\n+        # Chuyển đổi đơn vị tầm nhìn từ m sang km\r\n+        df['visibility'] = df['visibility'].apply(lambda f: f/1000)\r\n+        \r\n+        # Chuyển cột dt sang định dạng datetime\r\n+        df['dt'] = pd.to_datetime(df['dt'])\r\n+\r\n+        # Tạo cột week và year để nhóm\r\n+        df['week'] = df['dt'].dt.isocalendar().week\r\n+        df['year'] = df['dt'].dt.year\r\n+\r\n+        # Nhóm dữ liệu theo tuần và năm\r\n+        weekly_data = df.groupby(['year', 'week']).median().reset_index()\r\n+\r\n+        # Chuyển đổi cột week và year thành string để JSON serializable\r\n+        weekly_data['week'] = weekly_data['week'].astype(str)\r\n+        weekly_data['year'] = weekly_data['year'].astype(str)\r\n+\r\n+        # Kết hợp year và week vào một cột duy nhất để dễ hiểu\r\n+        weekly_data['year_week'] = weekly_data['year'] + '-W' + weekly_data['week']\r\n+\r\n+        # Loại bỏ các cột không cần thiết\r\n+        weekly_data = weekly_data.drop(columns=['year', 'week'])\r\n+        \r\n+        # Chuyển timestamp sang string để JSON serializable\r\n+        weekly_data['year_week'] = weekly_data['year_week'].astype(str)\r\n+        \r\n+        result = weekly_data.to_dict(orient='records')   \r\n+        return result\r\n+    except Exception as e:\r\n+        raise HTTPException(status_code=500, detail=str(e)) \r\n+\r\n+\r\n+#CORRELATON\r\n+#xóa correlation cũ\r\n+@app.delete(\"/api/correlation/delete\")\r\n+async def delete_correlation_data():  \r\n+    try:\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n+                query = \"DELETE FROM correlation_table\"\r\n+                await cur.execute(query)\r\n+                await conn.commit() # commit trên connection\r\n+        return {\"message\":\"Correlation old data deleted successfully\"}\r\n+    except Exception as e:\r\n+        logger.error(f\"error during delete operation: {e}\") # log the error messag\r\n+        raise HTTPException(status_code=500, detail=str(e)) \r\n+\r\n+@app.post(\"/api/correlation/bulk\")\r\n+async def save_correlation_bulk(data: List[CorrelationRecord]) -> Dict[str, Any]:\r\n     \"\"\"\r\n+    Save correlation data from a list of CorrelationRecord objects in bulk.\r\n+    \"\"\"\r\n     try:\r\n+        # Chuyển danh sách CorrelationRecord thành các tuple để insert\r\n+        values = [\r\n+            (\r\n+                record.temp, record.pressure, record.humidity,\r\n+                record.clouds, record.visibility, record.wind_speed, record.wind_deg\r\n+            ) for record in data\r\n+        ]\r\n+\r\n+        query = \"\"\"\r\n+        INSERT INTO correlation_table \r\n+        (temp, pressure, humidity, clouds, visibility, wind_speed, wind_deg) \r\n+        VALUES (%s, %s, %s, %s, %s, %s, %s)\r\n+        \"\"\"\r\n+\r\n         async with weather_api.pool.acquire() as conn:\r\n             async with conn.cursor() as cur:\r\n-                query = \"\"\"\r\n-                INSERT INTO raw_weather_data \r\n-                (dt, temp, pressure, humidity, clouds, visibility, wind_speed, wind_deg) \r\n-                VALUES (%s, %s, %s, %s, %s, %s, %s, %s)\r\n-                \"\"\"\r\n-                values = [\r\n-                    (data.dt, data.temp, data.pressure, data.humidity,\r\n-                     data.clouds, data.visibility, data.wind_speed, data.wind_deg)\r\n-                    for data in raw_data_list\r\n-                ]\r\n                 await cur.executemany(query, values)\r\n+                await conn.commit()\r\n \r\n         return {\r\n-            \"count\": len(raw_data_list),\r\n-            \"message\": \"Raw weather data saved successfully\"\r\n+            \"count\": len(values),\r\n+            \"message\": \"Correlation data saved successfully\"\r\n         }\r\n \r\n     except Exception as e:\r\n-        logger.error(f\"Error saving bulk raw weather data: {e}\")\r\n+        logger.error(f\"Error saving correlation data: {e}\")\r\n         raise HTTPException(status_code=500, detail=str(e))\r\n \r\n-@app.post(\"/api/process_weather/bulk\")\r\n-async def save_processed_weather_bulk(processed_data_list: List[WeatherData]) -> Dict[str, Any]:\r\n+##get data Correlation\r\n+@app.get(\"/correlation\")\r\n+async def get_correlation_data():\r\n+    try:\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor() as cur:\r\n+                await cur.execute(\"SELECT * FROM correlation_table\")\r\n+                rows = await cur.fetchall()\r\n+                if rows:\r\n+                    df = pd.DataFrame(rows)\r\n+                    logger.info(f\"Retrieved {len(df)} correlation records\")\r\n+                    return df.to_dict('records')\r\n+                return []\r\n+    except Exception as e:\r\n+        logger.error(f\"Error getting correlation data: {e}\")\r\n+        raise HTTPException(status_code=500, detail=str(e))\r\n+\r\n+##SEASONAL\r\n+@app.post(\"/api/seasonal/bulk\")\r\n+async def save_seasonal_bulk(data: List[SeasonalRecord]) -> Dict[str, Any]:\r\n     \"\"\"\r\n-    Save multiple processed weather data entries in bulk.\r\n-    \r\n-    Args:\r\n-        processed_data_list (List[WeatherData]): List of processed weather data objects\r\n-        \r\n-    Returns:\r\n-        Dict[str, Any]: Response containing count of saved entries and status message\r\n-        \r\n-    Raises:\r\n-        HTTPException: If database operation fails\r\n+    Save correlation data from a list of SeasonalRecord objects in bulk.\r\n     \"\"\"\r\n     try:\r\n+        # Chuyển danh sách CorrelationRecord thành các tuple để insert\r\n+        values = [\r\n+            (\r\n+                record.dt,\r\n+                record.observed_temp, \r\n+                record.trend_temp, \r\n+                record.seasonal_temp, \r\n+                record.residual_temp, \r\n+                \r\n+                record.observed_pressure, \r\n+                record.trend_pressure, \r\n+                record.seasonal_pressure, \r\n+                record.residual_pressure, \r\n+                \r\n+                record.observed_humidity, \r\n+                record.trend_humidity, \r\n+                record.seasonal_humidity, \r\n+                record.residual_humidity, \r\n+                \r\n+                record.observed_clouds, \r\n+                record.trend_clouds, \r\n+                record.seasonal_clouds, \r\n+                record.residual_clouds, \r\n+                \r\n+                record.observed_visibility, \r\n+                record.trend_visibility, \r\n+                record.seasonal_visibility, \r\n+                record.residual_visibility, \r\n+                \r\n+                record.observed_wind_speed, \r\n+                record.trend_wind_speed, \r\n+                record.seasonal_wind_speed, \r\n+                record.residual_wind_speed, \r\n+                \r\n+                record.observed_wind_deg, \r\n+                record.trend_wind_deg, \r\n+                record.seasonal_wind_deg, \r\n+                record.residual_wind_deg\r\n+            ) for record in data\r\n+        ]\r\n+\r\n+        query = \"\"\"\r\n+        INSERT INTO seasonal_table \r\n+        (   dt,\r\n+            observed_temp, \r\n+            trend_temp, \r\n+            seasonal_temp, \r\n+            residual_temp, \r\n+            \r\n+            observed_pressure, \r\n+            trend_pressure, \r\n+            seasonal_pressure, \r\n+            residual_pressure, \r\n+            \r\n+            observed_humidity, \r\n+            trend_humidity, \r\n+            seasonal_humidity, \r\n+            residual_humidity, \r\n+            \r\n+            observed_clouds, \r\n+            trend_clouds, \r\n+            seasonal_clouds, \r\n+            residual_clouds, \r\n+            \r\n+            observed_visibility, \r\n+            trend_visibility, \r\n+            seasonal_visibility, \r\n+            residual_visibility, \r\n+            \r\n+            observed_wind_speed, \r\n+            trend_wind_speed, \r\n+            seasonal_wind_speed, \r\n+            residual_wind_speed, \r\n+\r\n+            observed_wind_deg, \r\n+            trend_wind_deg, \r\n+            seasonal_wind_deg, \r\n+            residual_wind_deg) \r\n+        VALUES (%s, %s, %s, %s, %s, %s, %s,%s, %s, %s, %s, %s, %s, %s,%s, %s, %s, %s, %s, %s, %s,%s, %s, %s, %s, %s, %s, %s, %s)\r\n+        \"\"\"\r\n+\r\n         async with weather_api.pool.acquire() as conn:\r\n             async with conn.cursor() as cur:\r\n-                query = \"\"\"\r\n-                INSERT INTO processed_weather_data \r\n-                (dt, temp, pressure, humidity, clouds, visibility, wind_speed, wind_deg)\r\n-                VALUES (%s, %s, %s, %s, %s, %s, %s, %s)\r\n-                \"\"\"\r\n-                values = [\r\n-                    (data.dt, data.temp, data.pressure, data.humidity,\r\n-                     data.clouds, data.visibility, data.wind_speed, data.wind_deg)\r\n-                    for data in processed_data_list\r\n-                ]\r\n                 await cur.executemany(query, values)\r\n+                await conn.commit()\r\n \r\n         return {\r\n-            \"count\": len(processed_data_list),\r\n-            \"message\": \"Processed weather data saved successfully\"\r\n+            \"count\": len(values),\r\n+            \"message\": \"Seasonal data saved successfully\"\r\n         }\r\n \r\n     except Exception as e:\r\n-        logger.error(f\"Error saving bulk processed weather data: {e}\")\r\n+        logger.error(f\"Error saving correlation data: {e}\")\r\n         raise HTTPException(status_code=500, detail=str(e))\r\n \r\n+#xóa seasonal cũ\r\n+@app.delete(\"/api/seasonal/delete\")\r\n+async def delete_seasonal_data():  \r\n+    try:\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n+                query = \"DELETE FROM seasonal_table\"\r\n+                await cur.execute(query)\r\n+                await conn.commit() # commit trên connection\r\n+        return {\"message\":\"seasonal old data deleted successfully\"}\r\n+    except Exception as e:\r\n+        logger.error(f\"error during delete operation: {e}\") # log the error messag\r\n+        raise HTTPException(status_code=500, detail=str(e)) \r\n+\r\n+##get data seasonal\r\n+@app.get(\"/seasonal\")\r\n+async def get_filer() -> List[Dict[str, Any]]:  \r\n+    try:\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n+                query = \"SELECT * FROM seasonal_table\"\r\n+                await cur.execute(query)\r\n+                results = await cur.fetchall()\r\n+        \r\n+        # Chuyển đổi dữ liệu sang DataFrame\r\n+        df = pd.DataFrame(results)\r\n+         \r\n+        result = df.to_dict(orient='records')   \r\n+        return result\r\n+    except Exception as e:\r\n+        raise HTTPException(status_code=500, detail=str(e))  \r\n+# ====================================================================\r\n+\r\n+# =========================== API Tuyen ==============================\r\n @app.post(\"/api/cluster_data/bulk\")\r\n async def save_cluster_data_bulk(cluster_data: List[ClusterData]) -> Dict[str, Any]:\r\n+    \"\"\"\r\n+    Lưu dữ liệu phân cụm vào cơ sở dữ liệu theo từng batch để tránh mất dữ liệu.\r\n+    \"\"\"\r\n     try:\r\n         async with weather_api.pool.acquire() as conn:\r\n             async with conn.cursor() as cur:\r\n                 query = \"\"\"\r\n@@ -212,9 +889,9 @@\n                         logger.error(f\"Error saving batch starting at index {i}: {e}\")\r\n                         continue\r\n \r\n         return {\r\n-            \"count\": total_saved,\r\n+            \"count\": total_saved\r\n         }\r\n \r\n     except Exception as e:\r\n         logger.error(f\"Error saving bulk cluster data weather data: {e}\")\r\n@@ -244,136 +921,8 @@\n     except Exception as e:\r\n         logger.error(f\"Error deleting all cluster data: {e}\")\r\n         raise HTTPException(status_code=500, detail=str(e))\r\n \r\n-@app.post(\"/api/centroids\")\r\n-async def save_centroid(data_centroids: List[Centroid]) -> Dict[str, Any]:\r\n-    \"\"\"\r\n-    Lưu dữ liệu centroid vào cơ sở dữ liệu.\r\n-\r\n-    Args:\r\n-        data_centroids (List[Centroid]): Danh sách các centroid cần lưu.\r\n-\r\n-    Returns:\r\n-        Dict[str, Any]: Kết quả lưu trữ dữ liệu.\r\n-    \"\"\"\r\n-    try:\r\n-        # Kết nối đến cơ sở dữ liệu\r\n-        async with weather_api.pool.acquire() as conn:\r\n-            async with conn.cursor() as cur:\r\n-                # Truncate bảng trước khi chèn mới\r\n-                await cur.execute(\"TRUNCATE TABLE centroids\")\r\n-                logger.info(\"Cleared old centroids data.\")\r\n-\r\n-                # Câu lệnh chèn dữ liệu\r\n-                query = \"\"\"\r\n-                INSERT INTO centroids \r\n-                (cluster_name, temp, scaled_temp) \r\n-                VALUES (%s, %s, %s)\r\n-                \"\"\"\r\n-                # Tạo danh sách giá trị từ dữ liệu đầu vào\r\n-                values = [\r\n-                    (data.cluster_name, data.temp, data.scaled_temp)\r\n-                    for data in data_centroids\r\n-                ]\r\n-\r\n-                # Thực thi lệnh chèn dữ liệu hàng loạt\r\n-                await cur.executemany(query, values)\r\n-\r\n-        # Trả về kết quả thành công\r\n-        return {\r\n-            \"count\": len(data_centroids),\r\n-            \"message\": \"Centroids saved successfully\"\r\n-        }\r\n-\r\n-    except Exception as e:\r\n-        # Ghi log và trả về lỗi nếu xảy ra\r\n-        logger.error(f\"Error saving centroids data: {e}\")\r\n-        raise HTTPException(status_code=500, detail=str(e))\r\n-\r\n-@app.delete(\"/api/centroids\")\r\n-async def delete_all_cluster_data() -> Dict[str, Any]:\r\n-    try:\r\n-        async with weather_api.pool.acquire() as conn:\r\n-            async with conn.cursor() as cur:\r\n-                query = \"\"\"\r\n-                DELETE FROM centroids\r\n-                \"\"\"\r\n-                await cur.execute(query)  # Xóa toàn bộ dữ liệu trong bảng\r\n-                logger.info(\"All data in 'centroids' table has been deleted successfully.\")\r\n-\r\n-        return {\r\n-            \"message\": \"centroids data deleted successfully\"\r\n-        }\r\n-\r\n-    except Exception as e:\r\n-        logger.error(f\"Error deleting all centroids: {e}\")\r\n-        raise HTTPException(status_code=500, detail=str(e))\r\n-\r\n-\r\n-@app.post(\"/api/temp_pred\")\r\n-async def save_temp_pred(data: List[Temp_pred]) -> Dict[str, Any]:\r\n-    try:\r\n-        # Kết nối đến cơ sở dữ liệu\r\n-        async with weather_api.pool.acquire() as conn:\r\n-            async with conn.cursor() as cur:\r\n-                # Truncate bảng trước khi chèn mới\r\n-                await cur.execute(\"TRUNCATE TABLE temp_tomorrow_predict\")\r\n-                logger.info(\"Cleared old temp_tomorrow_predict data.\")\r\n-\r\n-                # Câu lệnh chèn dữ liệu\r\n-                query = \"\"\"\r\n-                INSERT INTO temp_tomorrow_predict \r\n-                (cluster_name, temp, scaled_temp) \r\n-                VALUES (%s, %s, %s)\r\n-                \"\"\"\r\n-                # Tạo danh sách giá trị từ dữ liệu đầu vào\r\n-                values = [\r\n-                    (data.temp_predict, data.prediction_date, data.date)\r\n-                    for data in data\r\n-                ]\r\n-\r\n-                # Thực thi lệnh chèn dữ liệu hàng loạt\r\n-                await cur.executemany(query, values)\r\n-\r\n-        # Trả về kết quả thành công\r\n-        return {\r\n-            \"count\": len(data),\r\n-            \"message\": \"temp_tomorrow_predict saved successfully\"\r\n-        }\r\n-\r\n-    except Exception as e:\r\n-        # Ghi log và trả về lỗi nếu xảy ra\r\n-        logger.error(f\"Error saving temp_tomorrow_predict data: {e}\")\r\n-        raise HTTPException(status_code=500, detail=str(e))\r\n-\r\n-\r\n-\r\n-\r\n-@app.get(\"/api/data_cluster\", response_model=List[ClusterData])\r\n-async def get_all_weather():\r\n-    try:\r\n-        async with weather_api.pool.acquire() as conn:\r\n-            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n-                query = \"SELECT * FROM cluster_data\"\r\n-                await cur.execute(query)\r\n-                results = await cur.fetchall()\r\n-                return [ClusterData(**row) for row in results]\r\n-    except Exception as e:\r\n-        raise HTTPException(status_code=500, detail=str(e))\r\n-\r\n-@app.get(\"/api/get_centroids\", response_model= List[Centroid])\r\n-async def get_centroid():\r\n-    try: \r\n-        async with weather_api.pool.acquire() as conn:\r\n-            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n-                query = \"SELECT * FROM centroids\"\r\n-                await cur.execute(query)\r\n-                results = await cur.fetchall()\r\n-                return [Centroid(**row) for row in results]\r\n-    except Exception as e:\r\n-        raise HTTPException(status_code=500, detail=str(e))\r\n-    \r\n @app.get(\"/api/weather/{timestamp}\", response_model=WeatherData)\r\n async def get_weather(timestamp: int):\r\n     \"\"\"\r\n     Get weather data for a specific timestamp.\r\n@@ -389,35 +938,26 @@\n     \"\"\"\r\n     try:\r\n         async with weather_api.pool.acquire() as conn:\r\n             async with conn.cursor(aiomysql.DictCursor) as cur:\r\n-                query = \"SELECT * FROM processed_weather_data WHERE dt = %s\"\r\n+                query = \"SELECT * FROM raw_weather_data WHERE dt = %s\"\r\n                 await cur.execute(query, (timestamp,))\r\n                 result = await cur.fetchone()\r\n                 if not result:\r\n                     raise HTTPException(status_code=404, detail=\"Weather data not found\")\r\n                 return WeatherData(**result)\r\n     except Exception as e:\r\n         raise HTTPException(status_code=500, detail=str(e))\r\n \r\n-@app.get(\"/api/weather\", response_model=List[WeatherData])\r\n-async def get_all_weather():\r\n-    \"\"\"\r\n-    Get all weather data entries ordered by timestamp descending.\r\n-    \r\n-    Returns:\r\n-        List[WeatherData]: List of all weather data objects\r\n-        \r\n-    Raises:\r\n-        HTTPException: If database error occurs\r\n-    \"\"\"\r\n-    try:\r\n+@app.get(\"/api/get_centroids\", response_model= List[Centroid])\r\n+async def get_centroid():\r\n+    try: \r\n         async with weather_api.pool.acquire() as conn:\r\n             async with conn.cursor(aiomysql.DictCursor) as cur:\r\n-                query = \"SELECT * FROM processed_weather_data ORDER BY dt DESC\"\r\n+                query = \"SELECT * FROM raw_weather_data ORDER BY dt DESC\"\r\n                 await cur.execute(query)\r\n                 results = await cur.fetchall()\r\n-                return [WeatherData(**row) for row in results]\r\n+                return [Centroid(**row) for row in results]\r\n     except Exception as e:\r\n         raise HTTPException(status_code=500, detail=str(e))\r\n \r\n # Run the application\r\n"
                },
                {
                    "date": 1733409642509,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,10 +12,18 @@\n from pymysqlreplication.row_event import WriteRowsEvent\r\n import pandas as pd\r\n \r\n from src.logger import logger\r\n-from src.db_api.weather import WeatherData\r\n+from .weather import WeatherData\r\n+from .cluster import ClusterData\r\n+from .controid import Centroid\r\n+from fastapi.middleware.cors import CORSMiddleware\r\n+from .weather import Temp_pred\r\n+from .weather import Spider\r\n+from .correlationModel import CorrelationRecord\r\n+from .seasonalModel import SeasonalRecord\r\n \r\n+\r\n # Load environment variables\r\n load_dotenv()\r\n \r\n app = FastAPI()\r\n@@ -270,16 +278,9 @@\n         except Exception as e:\r\n             logger.error(f\"Error publishing weather data: {e}\")\r\n             logger.error(f\"Weather data: {weather_data}\")\r\n \r\n-# Initialize FastAPI app with lifespan\r\n-app = FastAPI(\r\n-    title=\"Weather API\",\r\n-    lifespan=lifespan\r\n-)\r\n \r\n-weather_api = WeatherAPI()\r\n-\r\n # FastAPI endpoints\r\n @app.on_event(\"shutdown\")\r\n async def shutdown():\r\n     \"\"\"Close database connection on shutdown\"\"\"\r\n@@ -857,11 +858,8 @@\n \r\n # =========================== API Tuyen ==============================\r\n @app.post(\"/api/cluster_data/bulk\")\r\n async def save_cluster_data_bulk(cluster_data: List[ClusterData]) -> Dict[str, Any]:\r\n-    \"\"\"\r\n-    Lưu dữ liệu phân cụm vào cơ sở dữ liệu theo từng batch để tránh mất dữ liệu.\r\n-    \"\"\"\r\n     try:\r\n         async with weather_api.pool.acquire() as conn:\r\n             async with conn.cursor() as cur:\r\n                 query = \"\"\"\r\n@@ -889,9 +887,9 @@\n                         logger.error(f\"Error saving batch starting at index {i}: {e}\")\r\n                         continue\r\n \r\n         return {\r\n-            \"count\": total_saved\r\n+            \"count\": total_saved,\r\n         }\r\n \r\n     except Exception as e:\r\n         logger.error(f\"Error saving bulk cluster data weather data: {e}\")\r\n@@ -921,8 +919,173 @@\n     except Exception as e:\r\n         logger.error(f\"Error deleting all cluster data: {e}\")\r\n         raise HTTPException(status_code=500, detail=str(e))\r\n \r\n+# spider\r\n+@app.post(\"/api/spider\")\r\n+async def save_spider(data: List[Spider]) -> Dict[str, Any]:\r\n+    try:\r\n+        # Kết nối đến cơ sở dữ liệu\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor() as cur:\r\n+                # Truncate bảng trước khi chèn mới\r\n+                await cur.execute(\"TRUNCATE TABLE spider\")\r\n+                logger.info(\"Cleared old spider data.\")\r\n+\r\n+                # Câu lệnh chèn dữ liệu\r\n+                query = \"\"\"\r\n+                INSERT INTO spider \r\n+                (season, days, year) \r\n+                VALUES (%s, %s, %s)\r\n+                \"\"\"\r\n+                # Tạo danh sách giá trị từ dữ liệu đầu vào\r\n+                values = [\r\n+                    (data.season, data.days, data.year)\r\n+                    for data in data\r\n+                ]\r\n+\r\n+                # Thực thi lệnh chèn dữ liệu hàng loạt\r\n+                await cur.executemany(query, values)\r\n+\r\n+        # Trả về kết quả thành công\r\n+        return {\r\n+            \"count\": len(data),\r\n+            \"message\": \"Centroids saved successfully\"\r\n+        }\r\n+\r\n+    except Exception as e:\r\n+        # Ghi log và trả về lỗi nếu xảy ra\r\n+        logger.error(f\"Error saving centroids data: {e}\")\r\n+        raise HTTPException(status_code=500, detail=str(e))\r\n+\r\n+@app.get(\"/api/get_spider\", response_model= List[Spider])\r\n+async def get_spider():\r\n+    try: \r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n+                query = \"SELECT * FROM spider\"\r\n+                await cur.execute(query)\r\n+                results = await cur.fetchall()\r\n+                return [Spider(**row) for row in results]\r\n+    except Exception as e:\r\n+        raise HTTPException(status_code=500, detail=str(e))\r\n+\r\n+\r\n+@app.delete(\"/api/centroids\")\r\n+async def delete_all_cluster_data() -> Dict[str, Any]:\r\n+    try:\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor() as cur:\r\n+                query = \"\"\"\r\n+                DELETE FROM centroids\r\n+                \"\"\"\r\n+                await cur.execute(query)  # Xóa toàn bộ dữ liệu trong bảng\r\n+                logger.info(\"All data in 'centroids' table has been deleted successfully.\")\r\n+\r\n+        return {\r\n+            \"message\": \"centroids data deleted successfully\"\r\n+        }\r\n+\r\n+    except Exception as e:\r\n+        logger.error(f\"Error deleting all centroids: {e}\")\r\n+        raise HTTPException(status_code=500, detail=str(e))\r\n+\r\n+@app.get(\"/api/data_cluster\", response_model=List[ClusterData])\r\n+async def get_all_weather():\r\n+    try:\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n+                query = \"SELECT * FROM cluster_data\"\r\n+                await cur.execute(query)\r\n+                results = await cur.fetchall()\r\n+                return [ClusterData(**row) for row in results]\r\n+    except Exception as e:\r\n+        raise HTTPException(status_code=500, detail=str(e))\r\n+\r\n+@app.get(\"/api/get_centroids\", response_model= List[Centroid])\r\n+async def get_centroid():\r\n+    try: \r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n+                query = \"SELECT * FROM centroids\"\r\n+                await cur.execute(query)\r\n+                results = await cur.fetchall()\r\n+                return [Centroid(**row) for row in results]\r\n+    except Exception as e:\r\n+        raise HTTPException(status_code=500, detail=str(e))\r\n+\r\n+@app.get(\"/api/temp_pred\", response_model=Temp_pred)\r\n+async def get_temp_pred():\r\n+    try:\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n+                query = \"SELECT * FROM temp_tomorrow_predict\"\r\n+                logger.debug(f\"Executing query: {query}\")\r\n+                await cur.execute(query)\r\n+                result = await cur.fetchone()\r\n+                logger.debug(f\"Query result: {result}\")\r\n+\r\n+                if not result:\r\n+                    logger.warning(\"Không tìm thấy bản ghi dự đoán nhiệt độ trong bảng.\")\r\n+                    raise HTTPException(\r\n+                        status_code=404, \r\n+                        detail=\"Không tìm thấy dự đoán nhiệt độ\"\r\n+                    )\r\n+\r\n+                # Trả về kết quả\r\n+                logger.info(f\"Dữ liệu dự đoán nhiệt độ: {result}\")\r\n+                return Temp_pred(**result)\r\n+\r\n+    except aiomysql.Error as sql_error:\r\n+        logger.error(f\"Lỗi truy vấn SQL: {sql_error}\")\r\n+        raise HTTPException(\r\n+            status_code=500, \r\n+            detail=\"Lỗi khi truy vấn cơ sở dữ liệu\"\r\n+        )\r\n+\r\n+    except Exception as e:\r\n+        logger.error(f\"Lỗi không mong muốn khi lấy dữ liệu dự đoán nhiệt độ: {str(e)}\")\r\n+        raise HTTPException(\r\n+            status_code=500, \r\n+            detail=\"Lỗi khi truy vấn dữ liệu dự đoán nhiệt độ\"\r\n+        )\r\n+\r\n+@app.post(\"/api/temp_pred_save\")\r\n+async def save_temp_pred(data: Temp_pred) -> Dict[str, Any]:\r\n+    try:\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor() as cur:\r\n+                # Xóa dữ liệu cũ trước khi chèn mới\r\n+                # await cur.execute(\"TRUNCATE TABLE temp_tomorrow_predict\")\r\n+                # logger.info(\"Đã xóa dữ liệu cũ trong bảng temp_tomorrow_predict.\")\r\n+\r\n+                query = \"\"\"\r\n+                INSERT INTO temp_tomorrow_predict \r\n+                (temp_predict, date) \r\n+                VALUES (%s, %s)\r\n+                \"\"\"\r\n+                values = (data.temp_predict, data.date)\r\n+                await cur.execute(query, values)\r\n+                logger.info(\"Đã lưu dữ liệu dự đoán nhiệt độ mới.\")\r\n+\r\n+        return {\r\n+            \"message\": \"Đã lưu temp_tomorrow_predict thành công\"\r\n+        }\r\n+\r\n+    except aiomysql.Error as sql_error:\r\n+        logger.error(f\"Lỗi truy vấn SQL: {sql_error}\")\r\n+        raise HTTPException(\r\n+            status_code=500,\r\n+            detail=\"Lỗi khi lưu dữ liệu vào cơ sở dữ liệu\"\r\n+        )\r\n+\r\n+    except Exception as e:\r\n+        logger.error(f\"Lỗi khi lưu dữ liệu dự đoán nhiệt độ: {e}\")\r\n+        raise HTTPException(\r\n+            status_code=500,\r\n+            detail=\"Lỗi khi lưu dữ liệu dự đoán nhiệt độ\"\r\n+        )\r\n+\r\n @app.get(\"/api/weather/{timestamp}\", response_model=WeatherData)\r\n async def get_weather(timestamp: int):\r\n     \"\"\"\r\n     Get weather data for a specific timestamp.\r\n@@ -958,14 +1121,82 @@\n                 results = await cur.fetchall()\r\n                 return [Centroid(**row) for row in results]\r\n     except Exception as e:\r\n         raise HTTPException(status_code=500, detail=str(e))\r\n+    \r\n \r\n-# Run the application\r\n-if __name__ == \"__main__\":\r\n-    import uvicorn\r\n-    uvicorn.run(\r\n-        \"src.db_api.db_api:app\",\r\n-        host=\"0.0.0.0\", \r\n-        port=8000, \r\n-        reload=True\r\n\\ No newline at end of file\n-    ) \n+# ====================================================================\r\n+\r\n+@app.get(\"/api/prediction_chart\")\r\n+async def get_prediction_chart_data() -> Dict[str, Any]:\r\n+    \"\"\"\r\n+    Lấy dữ liệu nhiệt độ cho biểu đồ:\r\n+    - 9 giờ historical data từ processed_weather_data\r\n+    - 3 giờ predicted data từ predictions\r\n+    \"\"\"\r\n+    try:\r\n+        async with weather_api.pool.acquire() as conn:\r\n+            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n+                # Query lấy 9 giờ dữ liệu historical gần nhất\r\n+                historical_query = \"\"\"\r\n+                    SELECT \r\n+                        dt,\r\n+                        temp - 273.15 as temp,\r\n+                        FROM_UNIXTIME(dt) as formatted_time\r\n+                    FROM processed_weather_data\r\n+                    ORDER BY dt DESC\r\n+                    LIMIT 9;\r\n+                \"\"\"\r\n+                await cur.execute(historical_query)\r\n+                historical_results = await cur.fetchall()\r\n+\r\n+                # Query lấy 3 giờ dự đoán tiếp theo\r\n+                prediction_query = \"\"\"\r\n+                    SELECT \r\n+                        dt,\r\n+                        temp - 273.15 as temp,\r\n+                        formatted_time,\r\n+                        prediction_hour\r\n+                    FROM predictions \r\n+                    WHERE prediction_hour <= 3\r\n+                    ORDER BY dt ASC, prediction_hour ASC\r\n+                    LIMIT 3;\r\n+                \"\"\"\r\n+                await cur.execute(prediction_query)\r\n+                prediction_results = await cur.fetchall()\r\n+\r\n+        # Chuyển đổi kết quả thành list of dicts\r\n+        historical_data = [\r\n+            {\r\n+                \"timestamp\": row[\"dt\"],\r\n+                \"temperature\": round(float(row[\"temp\"]), 2),\r\n+                \"time\": row[\"formatted_time\"].strftime(\"%Y-%m-%d %H:%M:%S\"),\r\n+                \"type\": \"historical\"\r\n+            }\r\n+            for row in historical_results\r\n+        ]\r\n+        # Sắp xếp theo thời gian tăng dần\r\n+        historical_data.sort(key=lambda x: x[\"timestamp\"])\r\n+\r\n+        prediction_data = [\r\n+            {\r\n+                \"timestamp\": row[\"dt\"],\r\n+                \"temperature\": round(float(row[\"temp\"]), 2),\r\n+                \"time\": row[\"formatted_time\"],\r\n+                \"type\": \"predicted\",\r\n+                \"hour\": row[\"prediction_hour\"]\r\n+            }\r\n+            for row in prediction_results\r\n+        ]\r\n+\r\n+        return {\r\n+            \"status\": \"success\",\r\n+            \"data\": {\r\n+                \"historical\": historical_data,\r\n+                \"prediction\": prediction_data\r\n+            },\r\n+            \"message\": f\"Retrieved {len(historical_data)} historical and {len(prediction_data)} prediction records\"\r\n+        }\r\n+\r\n+    except Exception as e:\r\n+        logger.error(f\"Error getting temperature chart data: {e}\")\r\n+        raise HTTPException(status_code=500, detail=str(e))\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733409690241,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1084,34 +1084,8 @@\n             status_code=500,\r\n             detail=\"Lỗi khi lưu dữ liệu dự đoán nhiệt độ\"\r\n         )\r\n \r\n-@app.get(\"/api/weather/{timestamp}\", response_model=WeatherData)\r\n-async def get_weather(timestamp: int):\r\n-    \"\"\"\r\n-    Get weather data for a specific timestamp.\r\n-    \r\n-    Args:\r\n-        timestamp (int): Unix timestamp to query\r\n-        \r\n-    Returns:\r\n-        WeatherData: Weather data object for the specified timestamp\r\n-        \r\n-    Raises:\r\n-        HTTPException: If data not found or database error occurs\r\n-    \"\"\"\r\n-    try:\r\n-        async with weather_api.pool.acquire() as conn:\r\n-            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n-                query = \"SELECT * FROM raw_weather_data WHERE dt = %s\"\r\n-                await cur.execute(query, (timestamp,))\r\n-                result = await cur.fetchone()\r\n-                if not result:\r\n-                    raise HTTPException(status_code=404, detail=\"Weather data not found\")\r\n-                return WeatherData(**result)\r\n-    except Exception as e:\r\n-        raise HTTPException(status_code=500, detail=str(e))\r\n-\r\n @app.get(\"/api/get_centroids\", response_model= List[Centroid])\r\n async def get_centroid():\r\n     try: \r\n         async with weather_api.pool.acquire() as conn:\r\n"
                },
                {
                    "date": 1733409739844,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1084,21 +1084,8 @@\n             status_code=500,\r\n             detail=\"Lỗi khi lưu dữ liệu dự đoán nhiệt độ\"\r\n         )\r\n \r\n-@app.get(\"/api/get_centroids\", response_model= List[Centroid])\r\n-async def get_centroid():\r\n-    try: \r\n-        async with weather_api.pool.acquire() as conn:\r\n-            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n-                query = \"SELECT * FROM raw_weather_data ORDER BY dt DESC\"\r\n-                await cur.execute(query)\r\n-                results = await cur.fetchall()\r\n-                return [Centroid(**row) for row in results]\r\n-    except Exception as e:\r\n-        raise HTTPException(status_code=500, detail=str(e))\r\n-    \r\n-\r\n # ====================================================================\r\n \r\n @app.get(\"/api/prediction_chart\")\r\n async def get_prediction_chart_data() -> Dict[str, Any]:\r\n"
                },
                {
                    "date": 1733409927490,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -561,9 +561,8 @@\n         return result\r\n     except Exception as e:\r\n         raise HTTPException(status_code=500, detail=str(e))  \r\n     \r\n-    \r\n #RE-SAMPLING về tháng TREND\r\n @app.get(\"/resampleMonth\")\r\n async def get_filer() -> List[Dict[str, Any]]:  \r\n     try:\r\n@@ -653,9 +652,8 @@\n         return result\r\n     except Exception as e:\r\n         raise HTTPException(status_code=500, detail=str(e)) \r\n \r\n-\r\n #CORRELATON\r\n #xóa correlation cũ\r\n @app.delete(\"/api/correlation/delete\")\r\n async def delete_correlation_data():  \r\n@@ -885,13 +883,11 @@\n                         total_saved += len(values)\r\n                     except Exception as e:\r\n                         logger.error(f\"Error saving batch starting at index {i}: {e}\")\r\n                         continue\r\n-\r\n         return {\r\n             \"count\": total_saved,\r\n         }\r\n-\r\n     except Exception as e:\r\n         logger.error(f\"Error saving bulk cluster data weather data: {e}\")\r\n         raise HTTPException(status_code=500, detail=str(e))\r\n \r\n@@ -968,9 +964,8 @@\n                 return [Spider(**row) for row in results]\r\n     except Exception as e:\r\n         raise HTTPException(status_code=500, detail=str(e))\r\n \r\n-\r\n @app.delete(\"/api/centroids\")\r\n async def delete_all_cluster_data() -> Dict[str, Any]:\r\n     try:\r\n         async with weather_api.pool.acquire() as conn:\r\n"
                }
            ],
            "date": 1733386792611,
            "name": "Commit-0",
            "content": "from fastapi import FastAPI, HTTPException\r\nfrom typing import List, Dict, Any\r\nimport aiomysql\r\nimport httpx\r\nimport os\r\nimport sys\r\nfrom dotenv import load_dotenv\r\nfrom contextlib import asynccontextmanager\r\n\r\nsys.path.append(\".\")\r\nfrom src.logger import logger\r\nfrom src.db_api.weather import WeatherData\r\nfrom src.db_api.cluster import ClusterData\r\nfrom src.db_api.controid import Centroid\r\nfrom fastapi.middleware.cors import CORSMiddleware\r\n\r\n# Load environment variables\r\nload_dotenv()\r\n\r\nclass WeatherAPI:\r\n    \"\"\"\r\n    Weather API class that handles database connections and service calls.\r\n    Provides methods for database operations and service integrations.\r\n    \"\"\"\r\n    def __init__(self):\r\n        \"\"\"Initialize WeatherAPI with database pool and service endpoints\"\"\"\r\n        self.pool = None\r\n        # Backend service endpoints for future integrations\r\n        self.service_urls = {\r\n            \"analysis\": \"http://localhost:8001/analyze\",\r\n            \"clustering\": \"http://localhost:8002/cluster\",\r\n            \"classification\": \"http://localhost:8003/classify\",\r\n            \"prediction\": \"http://localhost:8004/predict\"\r\n        }\r\n\r\n    async def connect_db(self):\r\n        \"\"\"\r\n        Initialize database connection pool.\r\n        Uses environment variables for database configuration.\r\n        \"\"\"\r\n        if not self.pool:\r\n            self.pool = await aiomysql.create_pool(\r\n                host=os.getenv('DB_HOST'),\r\n                port=int(os.getenv('DB_PORT')),\r\n                user=os.getenv('DB_USER'),\r\n                password=os.getenv('DB_PASSWORD'),\r\n                db=os.getenv('DB_NAME'),\r\n                autocommit=True\r\n            )\r\n\r\n    async def close_db(self):\r\n        \"\"\"\r\n        Close database connection pool.\r\n        Should be called when shutting down the application.\r\n        \"\"\"\r\n        if self.pool:\r\n            self.pool.close()\r\n            await self.pool.wait_closed()\r\n\r\n    async def _call_service(self, service: str, weather_data: WeatherData) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Call backend service with weather data\r\n        Args:\r\n            service: Service name to call\r\n            weather_data: Weather data to process\r\n        Returns:\r\n            JSON response from service\r\n        \"\"\"\r\n        async with httpx.AsyncClient() as client:\r\n            response = await client.post(\r\n                self.service_urls[service],\r\n                json=weather_data.dict(),\r\n                timeout=30.0\r\n            )\r\n            return response.json()\r\n\r\n@asynccontextmanager\r\nasync def lifespan(app: FastAPI):\r\n    \"\"\"Lifespan events handler\"\"\"\r\n    # Startup\r\n    logger.info(\"Connecting to database...\")\r\n    await weather_api.connect_db()\r\n    yield\r\n    # Shutdown\r\n    logger.info(\"Closing database connection...\")\r\n    await weather_api.close_db()\r\n\r\n# Initialize FastAPI app with lifespan\r\napp = FastAPI(\r\n    title=\"Weather API\",\r\n    lifespan=lifespan\r\n)\r\n\r\norigins = [\r\n    \"http://localhost:3000\",  # Domain của frontend\r\n    # Thêm các domain khác nếu cần\r\n]\r\n\r\napp.add_middleware(\r\n    CORSMiddleware,\r\n    allow_origins=origins,  # Chỉ định domain được phép\r\n    allow_credentials=True,\r\n    allow_methods=[\"*\"],  # Cho phép tất cả các phương thức (GET, POST, ...)\r\n    allow_headers=[\"*\"],  # Cho phép tất cả các headers\r\n)\r\n\r\nweather_api = WeatherAPI()\r\n\r\n@app.post(\"/api/raw_weather/bulk\")\r\nasync def save_raw_weather_bulk(raw_data_list: List[WeatherData]) -> Dict[str, Any]:\r\n    \"\"\"\r\n    Save multiple raw weather data entries in bulk.\r\n    \r\n    Args:\r\n        raw_data_list (List[WeatherData]): List of weather data objects to be saved\r\n        \r\n    Returns:\r\n        Dict[str, Any]: Response containing count of saved entries and status message\r\n        \r\n    Raises:\r\n        HTTPException: If database operation fails\r\n    \"\"\"\r\n    try:\r\n        async with weather_api.pool.acquire() as conn:\r\n            async with conn.cursor() as cur:\r\n                query = \"\"\"\r\n                INSERT INTO raw_weather_data \r\n                (dt, temp, pressure, humidity, clouds, visibility, wind_speed, wind_deg) \r\n                VALUES (%s, %s, %s, %s, %s, %s, %s, %s)\r\n                \"\"\"\r\n                values = [\r\n                    (data.dt, data.temp, data.pressure, data.humidity,\r\n                     data.clouds, data.visibility, data.wind_speed, data.wind_deg)\r\n                    for data in raw_data_list\r\n                ]\r\n                await cur.executemany(query, values)\r\n\r\n        return {\r\n            \"count\": len(raw_data_list),\r\n            \"message\": \"Raw weather data saved successfully\"\r\n        }\r\n\r\n    except Exception as e:\r\n        logger.error(f\"Error saving bulk raw weather data: {e}\")\r\n        raise HTTPException(status_code=500, detail=str(e))\r\n\r\n@app.post(\"/api/process_weather/bulk\")\r\nasync def save_processed_weather_bulk(processed_data_list: List[WeatherData]) -> Dict[str, Any]:\r\n    \"\"\"\r\n    Save multiple processed weather data entries in bulk.\r\n    \r\n    Args:\r\n        processed_data_list (List[WeatherData]): List of processed weather data objects\r\n        \r\n    Returns:\r\n        Dict[str, Any]: Response containing count of saved entries and status message\r\n        \r\n    Raises:\r\n        HTTPException: If database operation fails\r\n    \"\"\"\r\n    try:\r\n        async with weather_api.pool.acquire() as conn:\r\n            async with conn.cursor() as cur:\r\n                query = \"\"\"\r\n                INSERT INTO processed_weather_data \r\n                (dt, temp, pressure, humidity, clouds, visibility, wind_speed, wind_deg)\r\n                VALUES (%s, %s, %s, %s, %s, %s, %s, %s)\r\n                \"\"\"\r\n                values = [\r\n                    (data.dt, data.temp, data.pressure, data.humidity,\r\n                     data.clouds, data.visibility, data.wind_speed, data.wind_deg)\r\n                    for data in processed_data_list\r\n                ]\r\n                await cur.executemany(query, values)\r\n\r\n        return {\r\n            \"count\": len(processed_data_list),\r\n            \"message\": \"Processed weather data saved successfully\"\r\n        }\r\n\r\n    except Exception as e:\r\n        logger.error(f\"Error saving bulk processed weather data: {e}\")\r\n        raise HTTPException(status_code=500, detail=str(e))\r\n\r\n@app.post(\"/api/cluster_data/bulk\")\r\nasync def save_cluster_data_bulk(cluster_data: List[ClusterData]) -> Dict[str, Any]:\r\n    try:\r\n        async with weather_api.pool.acquire() as conn:\r\n            async with conn.cursor() as cur:\r\n                query = \"\"\"\r\n                INSERT INTO cluster_data \r\n                (dt, temp, pressure, humidity, clouds, visibility, wind_speed, wind_deg, date, month, scaled_temp, kmean_label, custom_label)\r\n                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)\r\n                \"\"\"\r\n                # Tách dữ liệu thành các batch nhỏ (mỗi batch tối đa 100 dòng)\r\n                batch_size = 100\r\n                total_saved = 0\r\n\r\n                for i in range(0, len(cluster_data), batch_size):\r\n                    batch = cluster_data[i:i + batch_size]\r\n                    values = [\r\n                        (data.dt, data.temp, data.pressure, data.humidity,\r\n                         data.clouds, data.visibility, data.wind_speed, data.wind_deg,\r\n                         data.date, data.month, data.scaled_temp, data.kmean_label, data.custom_label)\r\n                        for data in batch\r\n                    ]\r\n\r\n                    try:\r\n                        await cur.executemany(query, values)\r\n                        total_saved += len(values)\r\n                    except Exception as e:\r\n                        logger.error(f\"Error saving batch starting at index {i}: {e}\")\r\n                        continue\r\n\r\n        return {\r\n            \"count\": total_saved,\r\n        }\r\n\r\n    except Exception as e:\r\n        logger.error(f\"Error saving bulk cluster data weather data: {e}\")\r\n        raise HTTPException(status_code=500, detail=str(e))\r\n\r\n@app.delete(\"/api/delete_all_data\")\r\nasync def delete_all_cluster_data() -> Dict[str, Any]:\r\n    \"\"\"\r\n    Xóa toàn bộ dữ liệu trong bảng cluster_data.\r\n    \r\n    Returns:\r\n        Dict[str, Any]: Trạng thái xóa dữ liệu.\r\n    \"\"\"\r\n    try:\r\n        async with weather_api.pool.acquire() as conn:\r\n            async with conn.cursor() as cur:\r\n                query = \"\"\"\r\n                DELETE FROM cluster_data\r\n                \"\"\"\r\n                await cur.execute(query)  # Xóa toàn bộ dữ liệu trong bảng\r\n                logger.info(\"All data in 'cluster_data' table has been deleted successfully.\")\r\n\r\n        return {\r\n            \"message\": \"Clustered weather data deleted successfully\"\r\n        }\r\n\r\n    except Exception as e:\r\n        logger.error(f\"Error deleting all cluster data: {e}\")\r\n        raise HTTPException(status_code=500, detail=str(e))\r\n\r\n@app.post(\"/api/centroids\")\r\nasync def save_centroid(data_centroids: List[Centroid]) -> Dict[str, Any]:\r\n    \"\"\"\r\n    Lưu dữ liệu centroid vào cơ sở dữ liệu.\r\n\r\n    Args:\r\n        data_centroids (List[Centroid]): Danh sách các centroid cần lưu.\r\n\r\n    Returns:\r\n        Dict[str, Any]: Kết quả lưu trữ dữ liệu.\r\n    \"\"\"\r\n    try:\r\n        # Kết nối đến cơ sở dữ liệu\r\n        async with weather_api.pool.acquire() as conn:\r\n            async with conn.cursor() as cur:\r\n                # Truncate bảng trước khi chèn mới\r\n                await cur.execute(\"TRUNCATE TABLE centroids\")\r\n                logger.info(\"Cleared old centroids data.\")\r\n\r\n                # Câu lệnh chèn dữ liệu\r\n                query = \"\"\"\r\n                INSERT INTO centroids \r\n                (cluster_name, temp, scaled_temp) \r\n                VALUES (%s, %s, %s)\r\n                \"\"\"\r\n                # Tạo danh sách giá trị từ dữ liệu đầu vào\r\n                values = [\r\n                    (data.cluster_name, data.temp, data.scaled_temp)\r\n                    for data in data_centroids\r\n                ]\r\n\r\n                # Thực thi lệnh chèn dữ liệu hàng loạt\r\n                await cur.executemany(query, values)\r\n\r\n        # Trả về kết quả thành công\r\n        return {\r\n            \"count\": len(data_centroids),\r\n            \"message\": \"Centroids saved successfully\"\r\n        }\r\n\r\n    except Exception as e:\r\n        # Ghi log và trả về lỗi nếu xảy ra\r\n        logger.error(f\"Error saving centroids data: {e}\")\r\n        raise HTTPException(status_code=500, detail=str(e))\r\n\r\n@app.delete(\"/api/centroids\")\r\nasync def delete_all_cluster_data() -> Dict[str, Any]:\r\n    try:\r\n        async with weather_api.pool.acquire() as conn:\r\n            async with conn.cursor() as cur:\r\n                query = \"\"\"\r\n                DELETE FROM centroids\r\n                \"\"\"\r\n                await cur.execute(query)  # Xóa toàn bộ dữ liệu trong bảng\r\n                logger.info(\"All data in 'centroids' table has been deleted successfully.\")\r\n\r\n        return {\r\n            \"message\": \"centroids data deleted successfully\"\r\n        }\r\n\r\n    except Exception as e:\r\n        logger.error(f\"Error deleting all centroids: {e}\")\r\n        raise HTTPException(status_code=500, detail=str(e))\r\n\r\n\r\n@app.post(\"/api/temp_pred\")\r\nasync def save_temp_pred(data: List[Temp_pred]) -> Dict[str, Any]:\r\n    try:\r\n        # Kết nối đến cơ sở dữ liệu\r\n        async with weather_api.pool.acquire() as conn:\r\n            async with conn.cursor() as cur:\r\n                # Truncate bảng trước khi chèn mới\r\n                await cur.execute(\"TRUNCATE TABLE temp_tomorrow_predict\")\r\n                logger.info(\"Cleared old temp_tomorrow_predict data.\")\r\n\r\n                # Câu lệnh chèn dữ liệu\r\n                query = \"\"\"\r\n                INSERT INTO temp_tomorrow_predict \r\n                (cluster_name, temp, scaled_temp) \r\n                VALUES (%s, %s, %s)\r\n                \"\"\"\r\n                # Tạo danh sách giá trị từ dữ liệu đầu vào\r\n                values = [\r\n                    (data.temp_predict, data.prediction_date, data.date)\r\n                    for data in data_centroids\r\n                ]\r\n\r\n                # Thực thi lệnh chèn dữ liệu hàng loạt\r\n                await cur.executemany(query, values)\r\n\r\n        # Trả về kết quả thành công\r\n        return {\r\n            \"count\": len(data),\r\n            \"message\": \"temp_tomorrow_predict saved successfully\"\r\n        }\r\n\r\n    except Exception as e:\r\n        # Ghi log và trả về lỗi nếu xảy ra\r\n        logger.error(f\"Error saving temp_tomorrow_predict data: {e}\")\r\n        raise HTTPException(status_code=500, detail=str(e))\r\n\r\n\r\n\r\n\r\n@app.get(\"/api/data_cluster\", response_model=List[ClusterData])\r\nasync def get_all_weather():\r\n    try:\r\n        async with weather_api.pool.acquire() as conn:\r\n            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n                query = \"SELECT * FROM cluster_data\"\r\n                await cur.execute(query)\r\n                results = await cur.fetchall()\r\n                return [ClusterData(**row) for row in results]\r\n    except Exception as e:\r\n        raise HTTPException(status_code=500, detail=str(e))\r\n\r\n@app.get(\"/api/get_centroids\", response_model= List[Centroid])\r\nasync def get_centroid():\r\n    try: \r\n        async with weather_api.pool.acquire() as conn:\r\n            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n                query = \"SELECT * FROM centroids\"\r\n                await cur.execute(query)\r\n                results = await cur.fetchall()\r\n                return [Centroid(**row) for row in results]\r\n    except Exception as e:\r\n        raise HTTPException(status_code=500, detail=str(e))\r\n    \r\n@app.get(\"/api/weather/{timestamp}\", response_model=WeatherData)\r\nasync def get_weather(timestamp: int):\r\n    \"\"\"\r\n    Get weather data for a specific timestamp.\r\n    \r\n    Args:\r\n        timestamp (int): Unix timestamp to query\r\n        \r\n    Returns:\r\n        WeatherData: Weather data object for the specified timestamp\r\n        \r\n    Raises:\r\n        HTTPException: If data not found or database error occurs\r\n    \"\"\"\r\n    try:\r\n        async with weather_api.pool.acquire() as conn:\r\n            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n                query = \"SELECT * FROM processed_weather_data WHERE dt = %s\"\r\n                await cur.execute(query, (timestamp,))\r\n                result = await cur.fetchone()\r\n                if not result:\r\n                    raise HTTPException(status_code=404, detail=\"Weather data not found\")\r\n                return WeatherData(**result)\r\n    except Exception as e:\r\n        raise HTTPException(status_code=500, detail=str(e))\r\n\r\n@app.get(\"/api/weather\", response_model=List[WeatherData])\r\nasync def get_all_weather():\r\n    \"\"\"\r\n    Get all weather data entries ordered by timestamp descending.\r\n    \r\n    Returns:\r\n        List[WeatherData]: List of all weather data objects\r\n        \r\n    Raises:\r\n        HTTPException: If database error occurs\r\n    \"\"\"\r\n    try:\r\n        async with weather_api.pool.acquire() as conn:\r\n            async with conn.cursor(aiomysql.DictCursor) as cur:\r\n                query = \"SELECT * FROM processed_weather_data ORDER BY dt DESC\"\r\n                await cur.execute(query)\r\n                results = await cur.fetchall()\r\n                return [WeatherData(**row) for row in results]\r\n    except Exception as e:\r\n        raise HTTPException(status_code=500, detail=str(e))\r\n\r\n# Run the application\r\nif __name__ == \"__main__\":\r\n    import uvicorn\r\n    uvicorn.run(\r\n        \"src.db_api.db_api:app\",\r\n        host=\"0.0.0.0\", \r\n        port=8000, \r\n        reload=True\r\n    ) "
        }
    ]
}